;; Unit tests for Scheme functions

(define right 0)
(define wrong 0)
(define report '())

(define verify
  (lambda (name ans f exp)
    (let* ((result (f exp ans))) ;; should be true
      (if (eq? result #t)
	  (begin 
	    (printf ".")
	    (set! right (+ right 1)))
	  (begin
	    (printf "F")
	    (set! report (cons (format "~a: was ~s; should be ~s" name ans exp) report))
	    (set! wrong (+ wrong 1)))))))

(printf "Scheme Unit tests~%")

(verify 'quasiquote `(list ,(+ 1 2) 4) equal? '(list 3 4))
(verify '% (% 10 3) equal? 1)
(verify '* (* 2 3) equal? 6)
(verify '+ (+ 7 8) equal? 15)
(verify '- (- 5 2) equal? 3)
(verify '/ (/ 3 4) equal? 3/4)
(verify '< (< 5 2) equal? #f)
(verify '<= (<= 5 6) equal? #t)
(verify '= (= 6 7) equal? #f)
(verify '> (> 9 2) equal? #t)
(verify '>= (>= 4 5) equal? #f)
;;(abort)
(verify 'abs (abs -1) equal? 1)
(verify 'and (and 4 1 2 #t '() 0) equal? 0)
(verify 'append (append '(1 2 3) '(4 5 6)) equal? '(1 2 3 4 5 6))
(verify 'apply (apply car '((1))) equal? 1)
;;(apply-with-keywords)
(verify 'assq (assq 1 '((1 2) (3 4))) equal? '(1 2))
(verify 'assv (assv 1 '((1 2) (3 4))) equal? '(1 2))
(verify 'atom? (atom? 1) equal? #t)
(verify 'boolean? (boolean? #t) equal? #t)
(verify 'caaaar (caaaar '(((((hello there) this is a test) what is this) another item) in the list)) equal? '(hello there))
(verify 'caaadr (caaadr '(((((hello there) this is a test) what is this) another item) ((((((1 2 3 ) 4 5 6) 7 8 9) 10 11 12) 13 14 15) 16 17 18))) 
	equal? '((((1 2 3) 4 5 6) 7 8 9) 10 11 12))
(verify 'caaar (caaar '(((((hello there) this is a test) what is this) another item) in the list)) equal? '((hello there) this is a test))
(verify 'caadar (caadar '(((((hello there) this is a test) what is this) (((1 2 3) 4 5 6) 7 8 9) another item) in the list)) equal? '((1 2 3) 4 5 6))
(verify 'caaddr (caaddr '(((((hello there) this is a test) what is this) (((1 2 3) 4 5 6) 7 8 9) another item) head ((1 2) 3 4) in the list)) equal? '(1 2))
(verify 'caadr (caadr '(((((hello there) this is a test) what is this) (((1 2 3) 4 5 6) 7 8 9) another item) (in this) ((7 8)) the list)) equal? 'in)
(verify 'caar (caar '(((((hello there) this is a test) what is this) another item) in the list)) equal? '(((hello there) this is a test) what is this))
(verify 'cadaar (cadaar '(((((hello there) this is a test) (what) is this) (yet another) item) in the list)) equal? '(what))
(verify 'cadadr (cadadr '(((((hello there) this is a test) what is this) (yet another) item) (in the) list)) equal? 'the)
(verify 'cadar (cadar '(((((hello there) this is a test) what is this) (yet another) item) in the list)) equal? '(yet another))
(verify 'caddar (caddar '(((((hello there) this is a test) what is this) another item) in the list)) equal? 'item)
(verify 'cadddr (cadddr '(((((hello there) this is a test) what is this) another item) in the list)) equal? 'list)
(verify 'caddr (caddr '(((((hello there) this is a test) what is this) another item) in the list)) equal? 'the)
(verify 'cadr (cadr '(((((hello there) this is a test) what is this) another item) in the list)) equal? 'in)
;;(call-with-current-continuation)
;;(call/cc)
(verify 'car (car '(((((hello there) this is a test) what is this) another item) in the list)) 
	equal? '((((hello there) this is a test) what is this) another item))
;;(case)
;;(cases)
(verify 'cd (cd) (lambda (a b) (string? a)) "")
(verify 'cdaaar (cdaaar '(((((hello there) this is a test) what is this) another item))) equal? '(this is a test))
(verify 'cdaadr (cdaadr '(((((hello there) this is a test) what is this) another item) ((7 8)) 9 10)) equal? '(8))
(verify 'cdaar (cdaar '(((((hello there) this is a test) what is this) another item))) equal? '(what is this))
(verify 'cdadar (cdadar '(((((hello there) this is a test) what is this) (another two) items))) equal? '(two))
(verify 'cdaddr (cdaddr '(((((hello there) this is a test) what is this) another item) 1 (2 5) 3 4)) equal? '(5))
(verify 'cdadr (cdadr '(((((hello there) this is a test) what is this) another item) (1 6) (2 5) 3 4)) equal? '(6))
(verify 'cdar (cdar '(((((hello there) this is a test) what is this) another item))) equal? '(another item))
(verify 'cddaar (cddaar '(((((hello there) this is a test) what is this) another item) 1 (2) 3)) equal? '(is this))
(verify 'cddadr (cddadr '(((((hello there) this is a test) what is this) another item) (7 13) (8 12) 9 10)) equal? '())
(verify 'cddar (cddar '(((((hello there) this is a test) what is this) another item))) equal? '(item))
(verify 'cdddar (cdddar '(((((hello there) this is a test) what is this) another item))) equal? '())
(verify 'cddddr (cddddr '(((((hello there) this is a test) what is this) another item) 1 2 3 4 5)) equal? '(4 5))
(verify 'cdddr (cdddr '(((((hello there) this is a test) what is this) another item) 1 2 3 4)) equal? '(3 4))
(verify 'cddr (cddr '(((((hello there) this is a test) what is this) another item) 1 2 3)) equal? '(2 3))
(verify 'cdr (cdr '(((((hello there) this is a test) what is this) another item) 1 2 3)) equal? '(1 2 3))
(verify 'char->integer (char->integer #\a) = 97)
(verify 'char->string (char->string #\b) equal? "b")
(verify 'char-alphabetic? (char-alphabetic? #\A) equal? #t)
(verify 'char-numeric? (char-numeric? #\1) equal? #t)
(verify 'char-whitespace? (char-whitespace? #\t) equal? #f)
(verify 'char-whitespace? (char-whitespace? #\tab) equal? #t)
(verify 'char-whitespace? (char-whitespace? #\newline) equal? #t)
(verify 'char-whitespace? (char-whitespace? #\a) equal? #f)
(verify 'char=? (char=? #\a #\a) equal? #t)
(verify 'char=? (char=? #\a #\b) equal? #f)
(verify 'char? (char? 2) equal? #f)
;;(cond)
(verify 'cons (cons 1 '()) equal? '(1))
(current-directory)
(current-environment)
(current-time)
;;(cut)
;;(define-datatype)
(dict)
(dir)
;;(display 1)
(eq? 'a 'a)
(equal? 1 1.0)
(eqv? 1 1)
;;(error "message ~a~%" 'ok)
(eval '(+ 1 2))
(eval-ast (parse '(+ 3 4)))
(even? 33)
;;(exit)
(float 23)
(for-each (lambda (n) (+ n 1)) '(1 2 3))
(format "~a ~s ~%" "hello" "hello")
;;(get)
(get-stack-trace)
(globals)
;;(import "test")
(int 12.8)
(integer->char 7)
(iter? 3)
(length '(1 2 3))
(let ((x 1)) x)
(let* ((x 1)(y (+ x 1))) y)
;;(letrec)
(list 1 2)
(list->string '(#\1 #\2 #\3))
(list->vector '(1 2 3))
(list-ref '(1 2 3) 1)
(list? '(1 2 3))
;;(load)
(make-set '(1 2 3 1 2))
(make-vector 3)
;;(map)
;;(member)
;;(memq)
;;(memv)
;;(newline)
;;(not)
;;(null?)
(number->string 23)
(number? 23)
(odd? 45)
(or #t (/ 1 0))
(pair? '())
(parse '(+ 1 2))
(parse-string "(- 7 8)")
;;(print "hello!")
;;(printf "hello ~a!" 'mate)
(procedure? procedure?)
;;(property)
(quotient 1 4)
(rac '(1 2 3))
(range 10)
(rational 3 4)
(rdc '(1 2 3))
(read-string '(1 2 3))
;;(record-case)
(remainder 1 4)
;;(require)
;;(reset-toplevel-env)
(reverse '(1 2 3))
(verify 'round-1 (round 45.5) = 46)
(verify 'round-2 (round 45.4) = 45)
(set-car! '(1 2 3) 0)
(set-cdr! '(1 2 3) '(3 4))
(snoc 0 '(1 2 3))
(verify 'sort (sort < '(3 7 1 2)) equal? '(1 2 3 7))
(verify 'sqrt (sqrt 3) equal? 1.7320508075688772)
(verify 'string (string #\1 #\2) equal? "12")
(verify 'string->list (string->list "hello world") 
	equal? '(#\h #\e #\l #\l #\o #\  #\w #\o #\r #\l #\d))
(verify 'string->number (string->number "12.1") equal? 12.1)
(verify 'string->symbol (string->symbol "hello") eq? 'hello)
(verify 'string-append (string-append "hell" "o") equal? "hello")
(verify 'string-length (string-length "what") = 4)
(verify 'string-ref (string-ref "what" 2) equal? #\a)
(string-split "hello.world" #\.)
(string<? "a" "b")
(string=? "a" "b")
(string? "hello")
(substring "hello" 1 3)
(symbol "hello")
(symbol->string 'hello)
(symbol? 'hello)
(typeof 23)
(unparse (parse '(+ 1 2)))
;;(unparse-procedure (lambda (n) (+ n 1)))
(use-lexical-address)
(use-stack-trace)
(use-tracing)
;;(using "Graphics")
(try 
 (using "math")
 (catch e e 
    (using "Graphics")))
(vector 1 2 3)
(vector->list (vector 1 2 3))
(vector-ref (vector 1 2 3) 2)
(vector-set! (vector 1 2 3) 2 'a)
(vector? (vector))
(verify '(void) (void) equal? (void))
(verify 'zero? (zero? 0.0) equal? #t)

(newline)
(for-each (lambda (m) (printf "~a ~%" m)) (reverse report))
(printf "~%Results:~%    right = ~s~%    wrong = ~s ~%" right wrong)
