<?xml version="1.0"?>
<doc>
    <assembly>
        <name>obj/Debug/IronPython.SQLite</name>
    </assembly>
    <members>
        <member name="T:Community.CsharpSqlite.Sqlite3.LockingStrategy">
            <summary>
            Basic locking strategy for Console/Winform applications
            </summary>
        </member>
        <member name="T:Community.CsharpSqlite.Sqlite3.MediumTrustLockingStrategy">
            <summary>
            Locking strategy for Medium Trust. It uses the same trick used in the native code for WIN_CE
            which doesn't support LockFileEx as well.
            </summary>
        </member>
        <member name="F:Community.CsharpSqlite.Sqlite3.Pager.eState">
            ***********************************************************************
            * The following block contains those class members that change during
            * routine opertion.  Class members not in this block are either fixed
            * when the pager is first created or else only change when there is a
            * significant mode change (such as changing the page_size, locking_mode,
            * or the journal_mode).  From another view, these class members describe
            * the "state" of the pager, while other class members describe the
            * "configuration" of the pager.</member>
        <member name="F:Community.CsharpSqlite.Sqlite3.PgHdr.nRef">
            *******************************************************************
            * Elements above are public.  All that follows is private to pcache.c
            * and should not be accessed by other modules.</member>
        <member name="T:Community.CsharpSqlite.Sqlite3.sqlite3_module">
            * The methods above are in version 1 of the sqlite_module object. Those</member>
        <member name="F:Community.CsharpSqlite.Sqlite3.INVALID_SET_FILE_POINTER">
            **************************************************************************
            * The next group of routines implement the I/O methods specified
            * by the sqlite3_io_methods object.
            ****************************************************************************</member>
        <member name="F:Community.CsharpSqlite.Sqlite3.etRADIX">
            * The rest are extensions, not normally found in printf() */</member>
        <member name="F:Community.CsharpSqlite.Sqlite3.SQLITE_OK">
            * beginning-of-error-codes */</member>
        <member name="F:Community.CsharpSqlite.Sqlite3.SQLITE_CONFIG_SINGLETHREAD">
            * previously SQLITE_CONFIG_CHUNKALLOC 12 which is now unused. */</member>
        <member name="F:Community.CsharpSqlite.Sqlite3.SQLITE_CREATE_INDEX">
            **************************************** 3rd ************ 4th **********</member>
        <member name="F:Community.CsharpSqlite.Sqlite3.zText">
            ** This file contains automatically generated code ******
            *
            * The code in this file has been automatically generated by
            *
            *   sqlite/tool/mkkeywordhash.c
            *
            * The code in this file implements a function that determines whether
            * or not a given identifier is really an SQL keyword.  The same thing
            * might be implemented more directly using a hand-written hash table.
            * But by using this automatically generated code, the size of the code
            * is substantially reduced.  This is important for embedded applications
            * on platforms with limited memory.
            ************************************************************************
            *  Included in SQLite3 port to C#-SQLite;  2008 Noah B Hart
            *  C#-SQLite is an independent reimplementation of the SQLite software library
            *
            *  SQLITE_SOURCE_ID: 2010-08-23 18:52:01 42537b60566f288167f1b5864a5435986838e3a3
            *
            ************************************************************************</member>
        <member name="F:Community.CsharpSqlite.Sqlite3.sqlite3PagerTrace">
            **************** NOTES ON THE DESIGN OF THE PAGER ************************
            *
            * This comment block describes invariants that hold when using a rollback
            * journal.  These invariants do not apply for journal_mode=WAL,
            * journal_mode=MEMORY, or journal_mode=OFF.
            *
            * Within this comment block, a page is deemed to have been synced
            * automatically as soon as it is written when PRAGMA synchronous=OFF.
            * Otherwise, the page is not synced until the xSync method of the VFS
            * is called successfully on the file containing the page.
            *
            * Definition:  A page of the database file is said to be "overwriteable" if
            * one or more of the following are true about the page:
            *
            *     (a)  The original content of the page as it was at the beginning of
            *          the transaction has been written into the rollback journal and
            *          synced.
            *
            *     (b)  The page was a freelist leaf page at the start of the transaction.
            *
            *     (c)  The page number is greater than the largest page that existed in
            *          the database file at the start of the transaction.
            *
            * (1) A page of the database file is never overwritten unless one of the
            *     following are true:
            *
            *     (a) The page and all other pages on the same sector are overwriteable.
            *
            *     (b) The atomic page write optimization is enabled, and the entire
            *         transaction other than the update of the transaction sequence
            *         number consists of a single page change.
            *
            * (2) The content of a page written into the rollback journal exactly matches
            *     both the content in the database when the rollback journal was written
            *     and the content in the database at the beginning of the current
            *     transaction.
            *
            * (3) Writes to the database file are an integer multiple of the page size
            *     in length and are aligned on a page boundary.
            *
            * (4) Reads from the database file are either aligned on a page boundary and
            *     an integer multiple of the page size in length or are taken from the
            *     first 100 bytes of the database file.
            *
            * (5) All writes to the database file are synced prior to the rollback journal
            *     being deleted, truncated, or zeroed.
            *
            * (6) If a master journal file is used, then all writes to the database file
            *     are synced prior to the master journal being deleted.
            *
            * Definition: Two databases (or the same database at two points it time)
            * are said to be "logically equivalent" if they give the same answer to
            * all queries.  Note in particular the the content of freelist leaf
            * pages can be changed arbitarily without effecting the logical equivalence
            * of the database.
            *
            * (7) At any time, if any subset, including the empty set and the total set,
            *     of the unsynced changes to a rollback journal are removed and the
            *     journal is rolled back, the resulting database file will be logical
            *     equivalent to the database file at the beginning of the transaction.
            *
            * (8) When a transaction is rolled back, the xTruncate method of the VFS
            *     is called to restore the database file to the same size it was at
            *     the beginning of the transaction.  (In some VFSes, the xTruncate
            *     method is a no-op, but that does not change the fact the SQLite will
            *     invoke it.)
            *
            * (9) Whenever the database file is modified, at least one bit in the range
            *     of bytes from 24 through 39 inclusive will be changed prior to releasing
            *     the EXCLUSIVE lock, thus signaling other connections on the same
            *     database to flush their caches.
            *
            * (10) The pattern of bits in bytes 24 through 39 shall not repeat in less
            *      than one billion transactions.
            *
            * (11) A database file is well-formed at the beginning and at the conclusion
            *      of every transaction.
            *
            * (12) An EXCLUSIVE lock is held on the database file when writing to
            *      the database file.
            *
            * (13) A SHARED lock is held on the database file while reading any
            *      content out of the database file.
            *
            ****************************************************************************</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.sqlite3_commit_hook(Community.CsharpSqlite.Sqlite3.sqlite3,Community.CsharpSqlite.Sqlite3.dxCommitCallback,System.Object)">
             EXPERIMENTAL ***
            *
            * Register a function to be invoked when a transaction comments.
            * If the invoked function returns non-zero, then the commit becomes a
            * rollback.</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.convertUtf8Filename(System.String)">
            *************************************************************************
            *************************** sqlite3_vfs methods ****************************
            *
            * This division contains the implementation of methods on the
            * sqlite3_vfs object.</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.sqlite3PCacheBufferSetup(System.Object,System.Int32,System.Int32)">
            **************************************************************************
            ***** Page Allocation/SQLITE_CONFIG_PCACHE Related Functions *************</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.pcache1ResizeHash(Community.CsharpSqlite.Sqlite3.PCache1)">
            **************************************************************************
            ***** General Implementation Functions ***********************************</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.pcache1Init``1(``0)">
            **************************************************************************
            ***** sqlite3_pcache Methods *********************************************</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.pcacheRemoveFromDirtyList(Community.CsharpSqlite.Sqlite3.PgHdr)">
            ******************************* Linked List Management *******************</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.sqlite3PcacheInitialize">
            ************************************************ General Interfaces ******
            *
            * Initialize and shutdown the page cache subsystem. Neither of these
            * functions are threadsafe.</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.sqlite3GetToken(System.String,System.Int32,System.Int32@)">
            * 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */
            * x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.sqlite3_value_blob(Community.CsharpSqlite.Sqlite3.Mem)">
            ************************* sqlite3_value_  *******************************
            * The following routines extract information from a Mem or sqlite3_value
            * structure.</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.setResultStrOrError(Community.CsharpSqlite.Sqlite3.sqlite3_context,System.String,System.Int32,System.Int32,System.Byte,Community.CsharpSqlite.Sqlite3.dxDel)">
            ************************* sqlite3_result_  *******************************
            * The following routines are used by user-defined functions to specify
            * the function result.
            *
            * The setStrOrError() funtion calls sqlite3VdbeMemSetStr() to store the
            * result as a string or blob but if the string or blob is too large, it
            * then sets the error code to SQLITE_TOOBIG</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.sqlite3_column_blob(Community.CsharpSqlite.Sqlite3.Vdbe,System.Int32)">
            ************************* sqlite3_column_  *******************************
            * The following routines are used to access elements of the current row
            * in the result set.</member>
        <member name="M:Community.CsharpSqlite.Sqlite3.vdbeUnbind(Community.CsharpSqlite.Sqlite3.Vdbe,System.Int32)">
            **************************** sqlite3_bind_  ***************************
            *
            * Routines used to attach values to wildcards in a compiled SQL statement.</member>
    </members>
</doc>
