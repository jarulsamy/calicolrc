/* Generated By:JavaCC: Do not edit this line. Parser.java */
package koala.dynamicjava.parser.impl;

import java.util.*;
import java.io.File;

import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.tuple.Pair;
import edu.rice.cs.plt.collect.ConsList;
import edu.rice.cs.plt.collect.CollectUtil;

import koala.dynamicjava.parser.wrapper.*;
import koala.dynamicjava.tree.*;
import koala.dynamicjava.tree.ModifierSet.Modifier;
import koala.dynamicjava.tree.visitor.*;
import koala.dynamicjava.util.*;
import koala.dynamicjava.tree.tiger.*;
import edu.rice.cs.dynamicjava.Options;

/**
 * This class represents a (interpreted) Java 1.1 language parser
 * adapted for 1.5 language extensions.
 */

public class Parser implements ParserConstants {
  /** The name of the file currently interpreted; null by default */
  private File file = null;

  /** DynamicJava options */
  private Options opt = Options.DEFAULT;

  /**
   * A flag to use in semantic lookaheads.  Declared here as a workaround because 
   * lookahead can't access local variables or production parameters.
   */
  private boolean lookaheadFlag;

  /** Hack to pass the fact that a formal parameter was varargs back to the method/constructor production. */
  boolean lastFormalParameterIsVarArgs = false;

  /**
   * The message reader
   */
  private LocalizedMessageReader reader =
    new LocalizedMessageReader("koala.dynamicjava.parser.resources.messages");

  /** Sets the current file */
  public void setFile(File f) { file = f; }

  public void setOptions(Options o) { opt = o; }

  private SourceInfo _range(Token first, Token last) {
    return SourceInfo.range(file, first.beginLine, first.beginColumn, last.endLine, last.endColumn);
  }

  private SourceInfo _range(Token first, SourceInfo.Wrapper last) {
    return SourceInfo.prepend(first.beginLine, first.beginColumn, last);
  }

  private SourceInfo _range(SourceInfo.Wrapper first, Token last) {
    return SourceInfo.extend(first, last.beginLine, last.beginColumn);
  }

  private SourceInfo _range(Token first, SourceInfo last) {
    return SourceInfo.prepend(first.beginLine, first.beginColumn, last);
  }

  private SourceInfo _range(SourceInfo first, Token last) {
    return SourceInfo.extend(first, last.beginLine, last.beginColumn);
  }

  private SourceInfo _range(SourceInfo.Wrapper first, SourceInfo.Wrapper last) {
    return SourceInfo.span(first, last);
  }

  private SourceInfo _range(SourceInfo first, SourceInfo last) {
    return SourceInfo.span(first, last);
  }

  /**
   * Throws a parse exception with the given message at the current (last consumed) token
   * @param message - the message to be thrown
   */

  private <T> T _throwParseException(String message) throws ParseException {
    ParseException pe = new ParseException(message);
    pe.currentToken = token;
    throw pe;
  }

  /**
   * Throws a parse exception with the given message at the current token, if the given
   * parse exception was one auto generated by the parser (not one of ours), but not if the
   * message is an <EOF> message, which is passed up to allow continuation of typing
   * @param pe - the previous parse exception thrown
   * @param message - the message to be thrown
   */
  private <T> T _throwParseException(ParseException pe, String message) throws ParseException {
    if (pe.expectedTokenSequences == null) { // has custom message
      message = pe.getMessage();
    }
    else {
      edu.rice.cs.plt.debug.DebugUtil.debug.log("Raw parse exception", pe);
    }
    if(pe.getMessage().indexOf("<EOF>\u005c"") != -1) {
      message = "Encountered Unexpected \u005c"<EOF>\u005c"";
    }
    return this.<T>_throwParseException(message);
  }

  public static enum DeclType { TOP, CLASS_MEMBER, INTERFACE_MEMBER, LOCAL, REPL };

  /**
   * Creates a field declaration
   */
  private FieldDeclaration createFieldDeclaration(ModifierSet  mods,
                                                  TypeName     typ,
                                                  Token        name,
                                                  Expression   exp,
                                                  int          dim) {
    SourceInfo si = (exp == null) ? _range(mods, name) : _range(mods, exp);

    // If the field is an array, create an array type node
    if (dim > 0) {
      typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
    }

    return new FieldDeclaration(mods, typ, name.image, exp, si);
  }

  /**
   * Creates a variable declaration
   */
  private VariableDeclaration createVariableDeclaration(ModifierSet  mods,
                                                        TypeName     typ,
                                                        Token        name,
                                                        Expression   exp,
                                                        int          dim) {
    SourceInfo si = (exp == null) ? _range(mods, name) : _range(mods, exp);

    // If the variable contains an array, create an array type node
    if (dim > 0) {
      typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
    }

    return new VariableDeclaration(mods, typ, name.image, exp, si);
  }


  private void checkModifiers(ModifierSet mods, ModifierSet.Modifier... allowed) throws ParseException {
    Set<ModifierSet.Modifier> copy = EnumSet.copyOf(mods.getFlags());
    for (ModifierSet.Modifier m : allowed) { copy.remove(m); }
    if (!copy.isEmpty()) {
      ModifierSet.Modifier badMod = copy.iterator().next();
      _throwParseException("Modifier " + badMod.getName() + " is not allowed here");
    }
  }


  /** A hierarchy of helper classes for building primary expressions. */
  abstract class Primary implements SourceInfo.Wrapper {
    private final SourceInfo _si;
    protected Primary(SourceInfo si) { _si = si; }
    public SourceInfo getSourceInfo() { return _si; }

    public Expression asExpression() throws ParseException {
      return _throwParseException("Incomplete expression");
    }
    public Primary dotId(Option<List<TypeName>> targs, Token id) throws ParseException {
      if (targs.isNone()) { return _throwParseException("Unexpected identifier"); }
      else { return _throwParseException("Unexpected type arguments and identifier"); }
    }
    public Primary dotThis(Option<List<TypeName>> targs, Token t) throws ParseException {
      if (targs.isNone()) { return _throwParseException("Unexpected 'this' keyword"); }
      else { return _throwParseException("Unexpected type arguments and 'this' keyword"); }
    }
    public Primary dotSuper(Option<List<TypeName>> targs, Token t) throws ParseException {
      if (targs.isNone()) { return _throwParseException("Unexpected 'super' keyword"); }
      else { return _throwParseException("Unexpected type arguments and 'super' keyword"); }
    }
    public Primary dotClass(Token t) throws ParseException {
      return _throwParseException("Illegal class literal");
    }
    public Primary dotNew(Option<List<TypeName>> targs, Token id) throws ParseException {
      if (targs.isNone()) { return _throwParseException("Unexpected 'new' keyword"); }
      else { return _throwParseException("Unexpected 'new' keyword and type arguments"); }
    }
    public Primary withArrayDim(Token last) throws ParseException {
      return _throwParseException("Unexpected empty array brackets");
    }
    public Primary withArrayAccess(Expression exp, Token last) throws ParseException {
      return _throwParseException("Unexpected array access");
    }
    public Primary withTypeArgs(List<TypeName> targs, Token last) throws ParseException {
      return _throwParseException("Unexpected type arguments");
    }
    public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      return _throwParseException("Unexpected argument list");
    }
    public Primary withClassBody(List<Node> members, Token last) throws ParseException {
      return _throwParseException("Unexpected class body");
    }
  }

  /** A primary that can be parsed as a complete expression and act as a method receiver, etc. */
  abstract class CompletedPrimary extends Primary {
    protected CompletedPrimary(SourceInfo si) { super(si); }

    @Override public abstract Expression asExpression() throws ParseException;

    @Override public Primary dotId(Option<List<TypeName>> targs, Token id) throws ParseException {
      if (targs.isNone()) { return new ObjectFieldAccessPrimary(asExpression(), id); }
      else { return new PartialObjectMethodCallPrimary(asExpression(), targs, id); }
    }

    @Override public Primary dotSuper(Option<List<TypeName>> targs, Token t) throws ParseException {
      return new PartialSuperConstructorCallPrimary(asExpression(), targs, t);
    }

    @Override public Primary dotNew(Option<List<TypeName>> targs, Token id) throws ParseException {
      return new PartialInnerAllocationPrimary(asExpression(), targs, id);
    }

    @Override public Primary withArrayAccess(Expression exp, Token last) throws ParseException {
      return new ExpressionPrimary(new ArrayAccess(asExpression(), exp, _range(this, last)));
    }
  }

  /** A primary that can *only* be parsed as the given expression, regardless of what follows. */
  class ExpressionPrimary extends CompletedPrimary {
    private Expression _exp;
    public ExpressionPrimary(Expression exp) { super(exp.getSourceInfo()); _exp = exp; }
    public Expression asExpression() { return _exp; }
  }

  /** Like an ExpressionPrimary, but constructor calls can't be followed by additional dots, etc. */
  class ConstructorCallPrimary extends Primary {
    private ConstructorCall _call;
    public ConstructorCallPrimary(ConstructorCall call) { super(call.getSourceInfo()); _call = call; }
    @Override public Expression asExpression() { return _call; }
  }

  /** An ExpressionPrimary, but doesn't allow array accesses. */
  class ArrayAllocationPrimary extends ExpressionPrimary {
    public ArrayAllocationPrimary(ArrayAllocation alloc) { super(alloc); }
    public Primary withArrayAccess(Expression exp, Token last) throws ParseException {
      return _throwParseException("Unexpected array access");
    }
  }


  /** A dotted sequence of names. */
  class AmbiguousNamePrimary extends CompletedPrimary {
    private final ConsList.Nonempty<IdentifierToken> _reversed;
    public AmbiguousNamePrimary(Token id) {
      this(ConsList.<IdentifierToken>singleton(new TreeToken(id, file)), _range(id, id));
    }
    private AmbiguousNamePrimary(ConsList.Nonempty<IdentifierToken> reversed, SourceInfo si) {
      super(si);
      _reversed = reversed;
    }
    private LinkedList<IdentifierToken> ids() { return CollectUtil.makeLinkedList(ConsList.reverse(_reversed)); }

    public Expression asExpression() {
      return new AmbiguousName(ids(), getSourceInfo());
    }

    @Override public Primary dotId(Option<List<TypeName>> targs, Token id) {
      if (targs.isNone()) {
        return new AmbiguousNamePrimary(ConsList.cons(new TreeToken(id, file), _reversed), _range(this, id));
      }
      else { return new PartialObjectMethodCallPrimary(asExpression(), targs, id); }
    }

    @Override public Primary dotThis(Option<List<TypeName>> targs, Token t) throws ParseException {
      if (targs.isNone()) {
        Option<String> cn = Option.some(TreeUtilities.listToName(ids()));
        return new ExpressionPrimary(new ThisExpression(cn, _range(this, t)));
      }
      else { return _throwParseException("Unexpected type arguments"); }
    }

    @Override public Primary dotSuper(Option<List<TypeName>> targs, Token t) throws ParseException {
      if (targs.isNone()) { return new PartialSuperPrimary(ids(), t); }
      else { return super.dotSuper(targs, t); }
    }

    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(new ReferenceTypeName(ids(), getSourceInfo()), _range(this, t)));
    }

    @Override public Primary withArrayDim(Token last) {
      TypeName elt = new ReferenceTypeName(ids(), getSourceInfo());
      return new ArrayTypeNamePrimary(new ArrayTypeName(elt, 1, false, _range(this, last)));
    }

    @Override public Primary withTypeArgs(List<TypeName> targs, Token last) {
      return new GenericReferenceTypeNamePrimary(_reversed, targs, _range(this, last));
    }

    @Override public Primary withArgs(List<Expression> args, Token last) {
      SourceInfo si = _range(this, last);
      ConsList<? extends IdentifierToken> revObjIds = _reversed.rest();
      if (revObjIds.isEmpty()) {
        return new ExpressionPrimary(new SimpleMethodCall(_reversed.first().image(), args, si));
      }
      else {
        LinkedList<IdentifierToken> objIds = CollectUtil.makeLinkedList(ConsList.reverse(revObjIds));
        AmbiguousName obj = new AmbiguousName(objIds, _range(objIds.getFirst(), objIds.getLast()));
        return new ExpressionPrimary(new ObjectMethodCall(obj, _reversed.first().image(), args, si));
      }
    }
  }

  /** A dotted name with at least one type argument.  Can be followed by additional identifiers and type arguments. */
  class GenericReferenceTypeNamePrimary extends Primary {
    protected final ConsList.Nonempty<IdentifierToken> _reversed;
    protected final ConsList.Nonempty<List<TypeName>> _targsReversed;
    public GenericReferenceTypeNamePrimary(ConsList.Nonempty<IdentifierToken> reversed, List<TypeName> targs,
                                           SourceInfo si) {
      super(si);
      _reversed = reversed;
      ConsList<List<TypeName>> noArgs = ConsList.empty();
      int noArgCount = _reversed.size() - 1;
      for (int i = 0; i < noArgCount; i++) { noArgs = ConsList.cons(new LinkedList<TypeName>(), noArgs); }
      _targsReversed = ConsList.cons(targs, noArgs);
    }
    private GenericReferenceTypeNamePrimary(ConsList.Nonempty<IdentifierToken> reversed,
                                            ConsList.Nonempty<List<TypeName>> targsReversed, SourceInfo si) {
      super(si);
      _reversed = reversed;
      _targsReversed = targsReversed;
    }

    protected GenericReferenceTypeName asTypeName() {
      List<IdentifierToken> ids = CollectUtil.makeLinkedList(ConsList.reverse(_reversed));
      List<List<? extends TypeName>> targs =
          CollectUtil.<List<? extends TypeName>>makeLinkedList(ConsList.reverse(_targsReversed));
      return new GenericReferenceTypeName(ids, targs, getSourceInfo());
    }

    @Override public Primary dotId(Option<List<TypeName>> targs, Token id) {
      if (targs.isNone()) { return new IdGenericReferenceTypeNamePrimary(this, id); }
      else { return new PartialStaticMethodCallPrimary(asTypeName(), targs, id); }
    }

    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(asTypeName(), _range(this, t)));
    }

    @Override public Primary withArrayDim(Token last) {
      return new ArrayTypeNamePrimary(new ArrayTypeName(asTypeName(), 1, false, _range(this, last)));
        }

  }

  /** A GenericReferenceTypeNamePrimary that ends with an id. */
  class IdGenericReferenceTypeNamePrimary extends GenericReferenceTypeNamePrimary {
    private final GenericReferenceTypeNamePrimary _prev;
    public IdGenericReferenceTypeNamePrimary(GenericReferenceTypeNamePrimary prev, Token id) {
      super(ConsList.cons(new TreeToken(id, file), prev._reversed),
            ConsList.cons(new LinkedList<TypeName>(), prev._targsReversed),
            _range(prev, id));
      _prev = prev;
    }
    @Override public Primary withTypeArgs(List<TypeName> targs, Token last) {
      ConsList.Nonempty<List<TypeName>> newTargs = ConsList.cons(targs, _targsReversed.rest());
      return new GenericReferenceTypeNamePrimary(_reversed, newTargs, _range(this, last));
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new ExpressionPrimary(new StaticMethodCall(_prev.asTypeName(), _reversed.first().image(),
                                                        args, _range(this, last)));
    }
  }

  /** An array type name. */
  class ArrayTypeNamePrimary extends Primary {
    private final ArrayTypeName _type;
    public ArrayTypeNamePrimary(ArrayTypeName type) { super(type.getSourceInfo()); _type = type; }
    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(_type, _range(this, t)));
    }
    @Override public Primary withArrayDim(Token last) {
      return new ArrayTypeNamePrimary(new ArrayTypeName(_type, 1, false, _range(this, last)));
    }
  }

  /** A primitive type, which may be part of a class literal or an array type. */
  class PrimitiveTypeNamePrimary extends Primary {
    private final PrimitiveTypeName _type;
    public PrimitiveTypeNamePrimary(PrimitiveTypeName type) { super(type.getSourceInfo()); _type = type; }
    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(_type, _range(this, t)));
    }
    @Override public Primary withArrayDim(Token last) {
      return new ArrayTypeNamePrimary(new ArrayTypeName(_type, 1, false, _range(this, last)));
    }
  }

  /** A "void" keyword, which may be part of a class literal. */
  class VoidTypeNamePrimary extends Primary {
    private final VoidTypeName _type;
    public VoidTypeNamePrimary(VoidTypeName type) { super(type.getSourceInfo()); _type = type; }
    @Override public Primary dotClass(Token t) {
      return new ExpressionPrimary(new TypeExpression(_type, _range(this, t)));
    }
  }


  /** Optional type arguments followed by a method name. */
  class PartialSimpleMethodCallPrimary extends Primary {
    private final Option<List<TypeName>> _targs;
    private final String _name;
    public PartialSimpleMethodCallPrimary(Option<List<TypeName>> targs, Token id, SourceInfo si) {
      super(si);
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      SourceInfo si = _range(this, last);
      return new ExpressionPrimary(new SimpleMethodCall(_targs, _name, args, si));
    }
  }

  /** An expression followed by a dot and a name.  May be followed by method arguments. */
  class ObjectFieldAccessPrimary extends CompletedPrimary {
    private final Expression _obj;
    private final String _name;
    public ObjectFieldAccessPrimary(Expression obj, Token id) {
      super(_range(obj, id));
      _obj = obj;
      _name = id.image;
    }
    public Expression asExpression() { return new ObjectFieldAccess(_obj, _name, getSourceInfo()); }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new ExpressionPrimary(new ObjectMethodCall(_obj, _name, args, _range(this, last)));
    }
  }

  /** An expression followed by a dot, optional type arguments, and a method name. */
  class PartialObjectMethodCallPrimary extends Primary {
    private final Expression _obj;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    public PartialObjectMethodCallPrimary(Expression obj, Option<List<TypeName>> targs, Token id) {
      super(_range(obj, id));
      _obj = obj;
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      SourceInfo si = _range(this, last);
      return new ExpressionPrimary(new ObjectMethodCall(_obj, _targs, _name, args, si));
    }
  }

  /** A type followed by a dot, optional type arguments, and a method name. */
  class PartialStaticMethodCallPrimary extends Primary {
    private final TypeName _type;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    PartialStaticMethodCallPrimary(TypeName type, Option<List<TypeName>> targs, Token id) {
      super(_range(type, id));
      _type = type;
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      SourceInfo si = _range(this, last);
      return new ExpressionPrimary(new StaticMethodCall(_type, _targs, _name, args, si));
    }
  }

  /** The "this" keyword.  May be a constructor call. */
  class ThisExpressionPrimary extends CompletedPrimary {
    public ThisExpressionPrimary(Token t) { super(_range(t, t)); }
    public Expression asExpression() {
      return new ThisExpression(Option.<String>none(), getSourceInfo());
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new ConstructorCallPrimary(new ConstructorCall(null, args, false, _range(this, last)));
    }
  }

  /** A "this" keyword prefixed by optional type arguments. */
  class PartialThisConstructorCallPrimary extends Primary {
    private final Option<List<TypeName>> _targs;
    public PartialThisConstructorCallPrimary(Option<List<TypeName>> targs, SourceInfo si) {
      super(si);
      _targs = targs;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      if (_targs.isSome()) {
        return _throwParseException("Parameterized this constructor calls are not yet supported");
      }
      return new ConstructorCallPrimary(new ConstructorCall(null, args, false, _range(this, last)));
    }
  }

  /** The "super" keyword, optionally prefixed by a dotted name.  May be a constructor call or a field/method access. */
  class PartialSuperPrimary extends Primary {
    private final LinkedList<IdentifierToken> _ids; // may be null
    public PartialSuperPrimary(Token t) { super(_range(t, t)); _ids = null; }
    public PartialSuperPrimary(LinkedList<IdentifierToken> ids, Token t) {
      super(_range(ids.getFirst(), t));
      _ids = ids;
    }
    @Override public Primary dotId(Option<List<TypeName>> targs, Token id) {
      Option<String> cn = (_ids == null) ? Option.<String>none() : Option.some(TreeUtilities.listToName(_ids));
      if (targs.isNone()) { return new SuperFieldAccessPrimary(cn, id, _range(this, id)); }
      else { return new PartialSuperMethodCallPrimary(cn, targs, id, _range(this, id)); }
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      Expression outer = null;
      if (_ids != null) { outer = new AmbiguousName(_ids, _range(_ids.getFirst(), _ids.getLast())); }
      return new ConstructorCallPrimary(new ConstructorCall(outer, args, true, _range(this, last)));
    }
  }

  /** A "super" keyword prefixed by optional type arguments.  Optionally prefixed by an outer expression. */
  class PartialSuperConstructorCallPrimary extends Primary {
    private final Expression _outer; // may be null
    private final Option<List<TypeName>> _targs;
    public PartialSuperConstructorCallPrimary(Option<List<TypeName>> targs, SourceInfo si) {
      super(si);
      _outer = null;
      _targs = targs;
    }
    public PartialSuperConstructorCallPrimary(Expression outer, Option<List<TypeName>> targs, Token last) {
      super(_range(outer, last));
      _outer = outer;
      _targs = targs;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      if (_targs.isSome()) {
        return _throwParseException("Parameterized super constructor calls are not yet supported");
      }
      return new ConstructorCallPrimary(new ConstructorCall(_outer, args, true, _range(this, last)));
    }
  }

  /**
   * A "super" keyword (optionally prefixed by a name), followed by a dot and a name.  May be followed by
   * method arguments.
   */
  class SuperFieldAccessPrimary extends CompletedPrimary {
    private final Option<String> _className;
    private final String _name;
    public SuperFieldAccessPrimary(Option<String> className, Token id, SourceInfo si) {
      super(si);
      _className = className;
      _name = id.image;
    }
    public Expression asExpression() throws ParseException {
      return new SuperFieldAccess(_className, _name, getSourceInfo());
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      return new ExpressionPrimary(new SuperMethodCall(_className, _name, args, _range(this, last)));
    }
  }

  /**
   * A "super" keyword (optionally prefixed by a name), followed by a dot, optional type arguments, and
   * a method name.
   */
  class PartialSuperMethodCallPrimary extends Primary {
    private final Option<String> _className;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    PartialSuperMethodCallPrimary(Option<String> className, Option<List<TypeName>> targs, Token id,
                                  SourceInfo si) {
      super(si);
      _className = className;
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) throws ParseException {
      SourceInfo si = _range(this, last);
      return new ExpressionPrimary(new SuperMethodCall(_className, _targs, _name, args, si));
    }
  }

  /** A "new" keyword followed by optional type arguments and a type. */
  class PartialSimpleAllocationPrimary extends Primary {
    private final Option<List<TypeName>> _targs;
    private final ReferenceTypeName _type;
    public PartialSimpleAllocationPrimary(Option<List<TypeName>> targs, ReferenceTypeName type, SourceInfo si) {
      super(si);
      _targs = targs;
      _type = type;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new SimpleAllocationPrimary(_targs, _type, args, _range(this, last));
    }
  }

  /**
   * A "new" keyword followed by optional type arguments, a type, and constructor arguments.  May
   * be an anonymous allocation if followed by a class body.
   */
  class SimpleAllocationPrimary extends CompletedPrimary {
    private final Option<List<TypeName>> _targs;
    private final ReferenceTypeName _type;
    private final List<Expression> _args;
    public SimpleAllocationPrimary(Option<List<TypeName>> targs, ReferenceTypeName type, List<Expression> args,
                                   SourceInfo si) {
      super(si);
      _targs = targs;
      _type = type;
      _args = args;
    }
    public Expression asExpression() {
      return new SimpleAllocation(_targs, _type, _args, getSourceInfo());
    }
    @Override public Primary withClassBody(List<Node> members, Token last) {
      SourceInfo si = _range(this, last);
      return new ExpressionPrimary(new AnonymousAllocation(_targs, _type, _args, members, si));
    }
  }

  /** An expression followed by a dot, "new", optional type arguments, and a class name. */
  class PartialInnerAllocationPrimary extends Primary {
    private final Expression _outer;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    public PartialInnerAllocationPrimary(Expression outer, Option<List<TypeName>> targs, Token id) {
      super(_range(outer, id));
      _outer = outer;
      _targs = targs;
      _name = id.image;
    }
    @Override public Primary withTypeArgs(List<TypeName> args, Token last) {
      return new PartialGenericInnerAllocationPrimary(_outer, _targs, _name, args, last);
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new InnerAllocationPrimary(_outer, _targs, _name, Option.<List<TypeName>>none(), args, last);
    }
  }

  /** An expression followed by a dot, "new", optional type arguments, a class name, and class type arguments. */
  class PartialGenericInnerAllocationPrimary extends Primary {
    private final Expression _outer;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    private final List<TypeName> _ctargs;
    public PartialGenericInnerAllocationPrimary(Expression outer, Option<List<TypeName>> targs, String name,
                                                List<TypeName> ctargs, Token last) {
      super(_range(outer, last));
      _outer = outer;
      _targs = targs;
      _name = name;
      _ctargs = ctargs;
    }
    @Override public Primary withArgs(List<Expression> args, Token last) {
      return new InnerAllocationPrimary(_outer, _targs, _name, Option.some(_ctargs), args, last);
    }
  }

  /**
   * An expresion followed by a dot, "new", optional type arguments, a class name, optional class type arguments,
   * and constructor arguments.  May be an anonymous allocation if followed by a class body.
   */
  class InnerAllocationPrimary extends CompletedPrimary {
    private final Expression _outer;
    private final Option<List<TypeName>> _targs;
    private final String _name;
    private final Option<List<TypeName>> _ctargs;
    private final List<Expression> _args;
    public InnerAllocationPrimary(Expression outer, Option<List<TypeName>> targs, String name,
                                  Option<List<TypeName>> ctargs, List<Expression> args, Token last) {
      super(_range(outer, last));
      _outer = outer;
      _targs = targs;
      _name = name;
      _ctargs = ctargs;
      _args = args;
    }
    public Expression asExpression() {
      return new InnerAllocation(_outer, _targs, _name, _ctargs, _args, getSourceInfo());
    }
    @Override public Primary withClassBody(List<Node> members, Token last) {
      SourceInfo si = _range(this, last);
          return new ExpressionPrimary(new AnonymousInnerAllocation(_outer, _targs, _name, _ctargs, _args, members, si));
    }
  }

  void _errorChar(char c) throws ParseException {
    _throwParseException("'" + c + "' expected.");
  }

  /*
   * The syntactic grammar
   */

  // Productions for the intepreter ////////////////////////////////////////////////

  /**
   * Parses input stream. This production is
   * not a Java language rule. It is used by DynamicJava.
   * @return a list of nodes (possibly empty)
   * @see koala.dynamicjava.tree.Node
   */
  final public List<Node> parseStream() throws ParseException {
    List<Node> list = new LinkedList<Node>(); List<Node> ns;
    try {
      label_1:
      while (true) {
        if (jj_2_1(1)) {
          ;
        } else {
          break label_1;
        }
        ns = replStatement();
                                list.addAll(ns);
      }
      jj_consume_token(0);
        {if (true) return list;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid top level statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses an item of the input stream. This production is
   * not a Java language rule. It is used by DynamicJava.
   * @return a list of nodes (a list because a single variable declaration
   * can be parsed to multiple VariableDeclaration nodes)
   * @see koala.dynamicjava.tree.Node
   */
  final public List<Node> replStatement() throws ParseException {
    ModifierSet mods; Node node = null; List<Node> nodes = null;
    try {
      if (jj_2_7(2)) {
        node = keywordStatement(false);
      } else if (jj_2_8(2)) {
        mods = modifiers();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PACKAGE:
          node = unmodifiedPackageDeclaration(mods, DeclType.REPL);
          break;
        case CLASS:
        case ENUM:
        case INTERFACE:
        case 132:
          node = unmodifiedTypeDeclaration(mods, DeclType.REPL);
          break;
        default:
          jj_la1[0] = jj_gen;
          if (jj_2_2(2147483647)) {
            node = unmodifiedMethodDeclaration(mods, DeclType.REPL);
          } else if (jj_2_3(2147483647)) {
            nodes = unmodifiedVariableDeclaration(mods, DeclType.REPL);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      } else if (jj_2_9(1)) {
        mods = noModifiers();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PACKAGE:
          node = unmodifiedPackageDeclaration(mods, DeclType.REPL);
          break;
        case IMPORT:
          node = importDeclaration();
          break;
        case CLASS:
        case ENUM:
        case INTERFACE:
        case 132:
          node = unmodifiedTypeDeclaration(mods, DeclType.REPL);
          break;
        default:
          jj_la1[1] = jj_gen;
          if (jj_2_4(2147483647)) {
            node = unmodifiedMethodDeclaration(mods, DeclType.REPL);
          } else if (jj_2_5(2147483647)) {
            nodes = unmodifiedVariableDeclaration(mods, DeclType.REPL);
          } else if (jj_2_6(1)) {
            node = nonKeywordStatement(false);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
        {if (true) return (node != null) ? Collections.singletonList(node) : nodes;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid top level statement");
    }
    throw new Error("Missing return statement in function");
  }

  // Productions for Packages ////////////////////////////////////////////////////////

  /**
   * Parses a Java compilation unit
   * @return a list of nodes (possibly empty)
   * @see koala.dynamicjava.tree.Node
   */
  final public CompilationUnit parseCompilationUnit() throws ParseException {
    ModifierSet mods;
    Token start = getToken(1);
    PackageDeclaration pkg = null;
    List<ImportDeclaration> imps = new LinkedList<ImportDeclaration>();
    ImportDeclaration imp;
    List<Node> decls = new LinkedList<Node>();
    Node decl;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
    case CLASS:
    case ENUM:
    case FINAL:
    case IMPORT:
    case INTERFACE:
    case NATIVE:
    case PACKAGE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 132:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
        label_2:
        while (true) {
          imp = importDeclaration();
                                    imps.add(imp);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IMPORT:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_2;
          }
        }
        break;
      case ABSTRACT:
      case CLASS:
      case ENUM:
      case FINAL:
      case INTERFACE:
      case NATIVE:
      case PACKAGE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case 132:
        mods = optionalModifiers();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PACKAGE:
          pkg = unmodifiedPackageDeclaration(mods, DeclType.TOP);
          label_3:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IMPORT:
              ;
              break;
            default:
              jj_la1[3] = jj_gen;
              break label_3;
            }
            imp = importDeclaration();
                                        imps.add(imp);
          }
          break;
        case CLASS:
        case ENUM:
        case INTERFACE:
        case 132:
          decl = unmodifiedTypeDeclaration(mods, DeclType.TOP);
                                                               decls.add(decl);
          break;
        default:
          jj_la1[4] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case CLASS:
        case ENUM:
        case FINAL:
        case INTERFACE:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOLATILE:
        case SEMICOLON:
        case 132:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_4;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case CLASS:
        case ENUM:
        case FINAL:
        case INTERFACE:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOLATILE:
        case 132:
          decl = typeDeclaration(DeclType.TOP);
                                             decls.add(decl);
          break;
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    jj_consume_token(0);
      {if (true) return new CompilationUnit(pkg, imps, decls, _range(start, token));}
    throw new Error("Missing return statement in function");
  }

  final public ModifierSet optionalModifiers() throws ParseException {
    ModifierSet mods = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
    case FINAL:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case 132:
      mods = modifiers();
                       {if (true) return mods;}
      break;
    default:
      jj_la1[9] = jj_gen;
      mods = noModifiers();
                         {if (true) return mods;}
    }
    throw new Error("Missing return statement in function");
  }

  /** Create an empty modifier set at the current location. */
  final public ModifierSet noModifiers() throws ParseException {
      SourceInfo si = SourceInfo.point(file, getToken(1).beginLine, getToken(1).beginColumn);
      {if (true) return new ModifierSet(EnumSet.noneOf(Modifier.class), new LinkedList<Annotation>(), si);}
    throw new Error("Missing return statement in function");
  }

  /**
   * Parse a nonempty list of modifiers and annotations
   */
  final public ModifierSet modifiers() throws ParseException {
    EnumSet<ModifierSet.Modifier> flags = EnumSet.noneOf(ModifierSet.Modifier.class);
    Annotation ann;
    List<Annotation> annots = new LinkedList<Annotation>();
    Token first = getToken(1);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
        jj_consume_token(ABSTRACT);
        if (flags.contains(Modifier.ABSTRACT)) {
          {if (true) throw new ParseError(reader.getMessage("abstract.abstract", null), _range(token, token));}
        }
        if (flags.contains(Modifier.FINAL)) {
          {if (true) throw new ParseError(reader.getMessage("abstract.final", null), _range(token, token));}
        }
        if (flags.contains(Modifier.NATIVE)) {
          {if (true) throw new ParseError(reader.getMessage("abstract.native", null), _range(token, token));}
        }
        flags.add(Modifier.ABSTRACT);
        break;
      case FINAL:
        jj_consume_token(FINAL);
        if (flags.contains(Modifier.FINAL)) {
          {if (true) throw new ParseError(reader.getMessage("final.final", null), _range(token, token));}
        }
        if (flags.contains(Modifier.ABSTRACT)) {
          {if (true) throw new ParseError(reader.getMessage("abstract.final", null), _range(token, token));}
        }
        flags.add(Modifier.FINAL);
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
        if (flags.contains(Modifier.PUBLIC)) {
          {if (true) throw new ParseError(reader.getMessage("public.public", null), _range(token, token));}
        }
        if (flags.contains(Modifier.PROTECTED)) {
          {if (true) throw new ParseError(reader.getMessage("public.protected", null), _range(token, token));}
        }
        if (flags.contains(Modifier.PRIVATE)) {
          {if (true) throw new ParseError(reader.getMessage("public.private", null), _range(token, token));}
        }
        flags.add(Modifier.PUBLIC);
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
        if (flags.contains(Modifier.PROTECTED)) {
          {if (true) throw new ParseError(reader.getMessage("protected.protected", null), _range(token, token));}
        }
        if (flags.contains(Modifier.PUBLIC)) {
          {if (true) throw new ParseError(reader.getMessage("public.protected", null), _range(token, token));}
        }
        if (flags.contains(Modifier.PRIVATE)) {
          {if (true) throw new ParseError(reader.getMessage("protected.private", null), _range(token, token));}
        }
        flags.add(Modifier.PROTECTED);
        break;
      case PRIVATE:
        jj_consume_token(PRIVATE);
        if (flags.contains(Modifier.PRIVATE)) {
          {if (true) throw new ParseError(reader.getMessage("private.private", null), _range(token, token));}
        }
        if (flags.contains(Modifier.PUBLIC)) {
          {if (true) throw new ParseError(reader.getMessage("public.private", null), _range(token, token));}
        }
        if (flags.contains(Modifier.PROTECTED)) {
          {if (true) throw new ParseError(reader.getMessage("protected.private", null), _range(token, token));}
        }
        flags.add(Modifier.PRIVATE);
        break;
      case TRANSIENT:
        jj_consume_token(TRANSIENT);
        if (flags.contains(Modifier.TRANSIENT)) {
          {if (true) throw new ParseError(reader.getMessage("transient.transient", null), _range(token, token));}
        }
        flags.add(Modifier.TRANSIENT);
        break;
      case VOLATILE:
        jj_consume_token(VOLATILE);
        if (flags.contains(Modifier.VOLATILE)) {
          {if (true) throw new ParseError(reader.getMessage("volatile.volatile", null), _range(token, token));}
        }
        flags.add(Modifier.VOLATILE);
        break;
      case NATIVE:
        jj_consume_token(NATIVE);
        if (flags.contains(Modifier.NATIVE)) {
          {if (true) throw new ParseError(reader.getMessage("native.native", null), _range(token, token));}
        }
        if (flags.contains(Modifier.ABSTRACT)) {
          {if (true) throw new ParseError(reader.getMessage("abstract.native", null), _range(token, token));}
        }
        flags.add(Modifier.NATIVE);
        break;
      case STATIC:
        jj_consume_token(STATIC);
        if (flags.contains(Modifier.STATIC)) {
          {if (true) throw new ParseError(reader.getMessage("static.static", null), _range(token, token));}
        }
        flags.add(Modifier.STATIC);
        break;
      case SYNCHRONIZED:
        jj_consume_token(SYNCHRONIZED);
        if (flags.contains(Modifier.SYNCHRONIZED)) {
          {if (true) throw new ParseError(reader.getMessage("synchronized.synchronized", null), _range(token, token));}
        }
        flags.add(Modifier.SYNCHRONIZED);
        break;
      case STRICTFP:
        jj_consume_token(STRICTFP);
        if (flags.contains(Modifier.STRICT)) {
          {if (true) throw new ParseError(reader.getMessage("strictfp.strictfp", null), _range(token, token));}
        }
        flags.add(Modifier.STRICT);
        break;
      case 132:
        ann = annotation();
        annots.add(ann);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_10(2)) {
        ;
      } else {
        break label_5;
      }
    }
      {if (true) return new ModifierSet(flags, annots, _range(first, token));}
    throw new Error("Missing return statement in function");
  }

  final public PackageDeclaration packageDeclaration(DeclType level) throws ParseException {
    ModifierSet mods; PackageDeclaration decl;
    try {
      mods = optionalModifiers();
      decl = unmodifiedPackageDeclaration(mods, level);
                                                                                    {if (true) return decl;}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid package declaration");
    }
    throw new Error("Missing return statement in function");
  }

  final public PackageDeclaration unmodifiedPackageDeclaration(ModifierSet mods, DeclType level) throws ParseException {
    ReferenceTypeName name = null;
    try {
      jj_consume_token(PACKAGE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        name = referenceTypeName();
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      optionalSemicolon();
        if(name instanceof GenericReferenceTypeName){
          _throwParseException("Package names cannot be parameterized.");
        }
        if(name == null) {
          _throwParseException("Empty package name");
        }
        checkModifiers(mods); // only annotations are allowed
        {if (true) return new PackageDeclaration(mods, name.getRepresentation(), _range(mods, token));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid package declaration");
    }
    throw new Error("Missing return statement in function");
  }

  final public ImportDeclaration importDeclaration() throws ParseException {
    ReferenceTypeName name = null;
    Token star = null;
    Token t1, t2;
    Token sttic = null;
    try {
      t1 = jj_consume_token(IMPORT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATIC:
        sttic = jj_consume_token(STATIC);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        name = referenceTypeName();
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        star = jj_consume_token(STAR);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      t2 = optionalSemicolon();
        if(name instanceof GenericReferenceTypeName){
          _throwParseException("Import names cannot be parameterized.");
        }
        if(name == null) {
          _throwParseException("Missing name - Cannot import");
        }
        {if (true) return new ImportDeclaration(name.getRepresentation(), star != null, sttic != null, _range(t1, t2));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid Import Declaration");
    }
    throw new Error("Missing return statement in function");
  }

  final public TypeDeclaration typeDeclaration(DeclType level) throws ParseException {
    ModifierSet mods; TypeDeclaration decl;
    try {
      mods = optionalModifiers();
      decl = unmodifiedTypeDeclaration(mods, level);
                                                                                 {if (true) return decl;}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid declaration");
    }
    throw new Error("Missing return statement in function");
  }

  final public TypeDeclaration unmodifiedTypeDeclaration(ModifierSet mods, DeclType level) throws ParseException {
    TypeDeclaration node;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        node = unmodifiedClassDeclaration(mods, level);
        break;
      case ENUM:
        node = unmodifiedEnumDeclaration(mods, level);
        break;
      case INTERFACE:
      case 132:
        node = unmodifiedInterfaceDeclaration(mods, level);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        {if (true) return node;}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid declaration");
    }
    throw new Error("Missing return statement in function");
  }

  // Productions for Names ////////////////////////////////////////////////////////

  /**
   * Parses a name
   * @return a list of tree token
   * @see koala.dynamicjava.parser.wrapper.TreeToken
   */
  final public List<IdentifierToken> name() throws ParseException {
    Token id;
    List<IdentifierToken>  list = new LinkedList<IdentifierToken>();
    id = jj_consume_token(IDENTIFIER);
      list.add(new TreeToken(id, file));
    label_6:
    while (true) {
      if (jj_2_11(2)) {
        ;
      } else {
        break label_6;
      }
      jj_consume_token(DOT);
      id = jj_consume_token(IDENTIFIER);
      list.add(new TreeToken(id, file));
    }
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  // Production for a ReferenceTypeName ////////////////////////////////////////////////////////

  /**
   * Consumes as large a name as possible: the type must not be followed by ".[id]" or "<", because
   * the parser will assume those delimiters mark a continuation of the ReferenceTypeName.
   */
  final public ReferenceTypeName referenceTypeName() throws ParseException {
    Token id = null;
    LinkedList<IdentifierToken> ids = new LinkedList<IdentifierToken>();
    List<TypeName> targs = null;
    boolean parameterized = false;
    List<List<? extends TypeName>> allTypeArgs = new LinkedList<List<? extends TypeName>>();
    try {
      id = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS:
        targs = typeArguments();
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
        ids.add(new TreeToken(id, file));
        allTypeArgs.add((targs == null) ? new LinkedList<TypeName>() : targs);
        parameterized |= targs != null;
        targs = null;
      label_7:
      while (true) {
        if (jj_2_12(2)) {
          ;
        } else {
          break label_7;
        }
        jj_consume_token(DOT);
        id = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LESS:
          targs = typeArguments();
          break;
        default:
          jj_la1[17] = jj_gen;
          ;
        }
            ids.add(new TreeToken(id, file));
            allTypeArgs.add((targs == null) ? new LinkedList<TypeName>() : targs);
            parameterized |= targs != null;
            targs = null;
      }
        SourceInfo si = _range(ids.getFirst(), token);
        if (parameterized) { {if (true) return new GenericReferenceTypeName(ids, allTypeArgs, si);} }
        else { {if (true) return new ReferenceTypeName(ids, si);} }
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid reference name");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a comma separated list of ReferenceTypeName names
   * @return a list of ReferenceTypeName
   * @see koala.dynamicjava.tree.ReferenceTypeName
   */
  final public List<? extends ReferenceTypeName> ReferenceTypeNameList() throws ParseException {
    List<ReferenceTypeName> list = new LinkedList<ReferenceTypeName>();
    ReferenceTypeName obj;
    obj = referenceTypeName();
                              list.add(obj);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      obj = referenceTypeName();
                                    list.add(obj);
    }
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  // Productions for Classes //////////////////////////////////////////////////////

  // Productions for Class Declaration ============================================

  /**
   * Parses a class declaration
   * @see koala.dynamicjava.tree.ClassDeclaration
   */
  final public ClassDeclaration classDeclaration(DeclType level) throws ParseException {
    ClassDeclaration cd; ModifierSet md;
    md = optionalModifiers();
    cd = unmodifiedClassDeclaration(md, level);
                                                                      {if (true) return cd;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a class declaration without modifier
   * @see koala.dynamicjava.tree.ClassDeclaration
   */
  final public ClassDeclaration unmodifiedClassDeclaration(ModifierSet mods, DeclType level) throws ParseException {
    Token t;
    Token id;
    List<TypeParameter> typeParameters = null;
    ReferenceTypeName  ext  = null;
    List<? extends ReferenceTypeName> impl = null;
    List<Node> body;
    t = jj_consume_token(CLASS);
    id = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LESS:
      typeParameters = typeParameters();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      jj_consume_token(EXTENDS);
      ext = referenceTypeName();
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      jj_consume_token(IMPLEMENTS);
      impl = ReferenceTypeNameList();
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    body = classBody();
      switch (level) {
        case TOP: checkModifiers(mods, Modifier.PUBLIC, Modifier.FINAL, Modifier.ABSTRACT, Modifier.STRICT); break;
        case CLASS_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.PROTECTED, Modifier.PRIVATE,
                                          Modifier.STATIC, Modifier.FINAL, Modifier.ABSTRACT, Modifier.STRICT); break;
        case INTERFACE_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL,
                                              Modifier.ABSTRACT, Modifier.STRICT); break;
        case LOCAL: checkModifiers(mods, Modifier.FINAL, Modifier.ABSTRACT, Modifier.STRICT); break;
        case REPL: checkModifiers(mods, Modifier.PUBLIC, Modifier.FINAL, Modifier.ABSTRACT, Modifier.STRICT); break;
      }
      {if (true) return new ClassDeclaration(mods, id.image, Option.wrap(typeParameters), ext, impl, body, _range(mods, token));}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse the body of a class
   */
  final public List<Node> classBody() throws ParseException {
    List<Node> list = new LinkedList<Node>();
    List<Node> decl;
    try {
      jj_consume_token(LBRACE);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case IDENTIFIER:
        case LBRACE:
        case SEMICOLON:
        case LESS:
        case 132:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_9;
        }
        decl = classBodyDeclaration();
                                        list.addAll(decl);
      }
      jj_consume_token(RBRACE);
        {if (true) return list;}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid class body");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses one declaration in the body of a class.
   * @return a list of node because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  final public List<Node> classBodyDeclaration() throws ParseException {
    ModifierSet mods;
    Node node = null;
    List<Node> list = new LinkedList<Node>();
    try {
      if (jj_2_16(2)) {
        node = initializer();
                                        list.add(node); {if (true) return list;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
            {if (true) return list;}
          break;
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case IDENTIFIER:
        case LESS:
        case 132:
          mods = optionalModifiers();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CLASS:
          case ENUM:
          case INTERFACE:
          case 132:
            node = unmodifiedTypeDeclaration(mods, DeclType.CLASS_MEMBER);
            break;
          default:
            jj_la1[23] = jj_gen;
            if (jj_2_13(2147483647)) {
              node = unmodifiedConstructorDeclaration(mods);
            } else if (jj_2_14(2147483647)) {
              node = unmodifiedMethodDeclaration(mods, DeclType.CLASS_MEMBER);
            } else if (jj_2_15(2147483647)) {
              list = unmodifiedVariableDeclaration(mods, DeclType.CLASS_MEMBER);
            } else {
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        if (node != null) { list.add(node); } {if (true) return list;}
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid member declaration");
    }
    throw new Error("Missing return statement in function");
  }

  // Productions for variable declaration ============================================

  /**
   * Parses a variable (field or local) declaration.
   * @return a list of field declaration because one variable declaration can
   *         contain multiple declarations.
   */
  final public List<Node> variableDeclaration(DeclType level) throws ParseException {
    ModifierSet mods; List<Node> decls;
    try {
      mods = optionalModifiers();
      decls = unmodifiedVariableDeclaration(mods, level);
                                                                                      {if (true) return decls;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid variable declaration");
    }
    throw new Error("Missing return statement in function");
  }

  final public List<Node> unmodifiedVariableDeclaration(ModifierSet mods, DeclType level) throws ParseException {
    TypeName      typ;
    Token         id;
    int           dim  = 0;
    Expression    exp  = null;
    List<Node>    list = new LinkedList<Node>();
    try {
      typ = type();
      id = jj_consume_token(IDENTIFIER);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_10;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                    dim++;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        exp = variableInitializer();
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
              switch (level) {
                case CLASS_MEMBER:
                  checkModifiers(mods, Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED, Modifier.STATIC,
                                 Modifier.FINAL, Modifier.VOLATILE, Modifier.TRANSIENT);
                  list.add(createFieldDeclaration(mods, typ, id, exp, dim));
                  break;
                case INTERFACE_MEMBER:
                  checkModifiers(mods, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
                  list.add(createFieldDeclaration(mods, typ, id, exp, dim));
                  break;
                case REPL:
                  checkModifiers(mods, Modifier.PUBLIC, Modifier.FINAL);
                  list.add(createVariableDeclaration(mods, typ, id, exp, dim));
                  break;
                default:
                  checkModifiers(mods, Modifier.FINAL);
                  list.add(createVariableDeclaration(mods, typ, id, exp, dim));
                  break;
              }
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[27] = jj_gen;
          break label_11;
        }
        jj_consume_token(COMMA);
                dim = 0; exp = null;
        id = jj_consume_token(IDENTIFIER);
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            ;
            break;
          default:
            jj_la1[28] = jj_gen;
            break label_12;
          }
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
                     dim++;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGN:
          jj_consume_token(ASSIGN);
          exp = variableInitializer();
          break;
        default:
          jj_la1[29] = jj_gen;
          ;
        }
             switch (level) {
               case CLASS_MEMBER:
               case INTERFACE_MEMBER:
                 list.add(createFieldDeclaration(mods, typ, id, exp, dim));
                 break;
               default:
                 list.add(createVariableDeclaration(mods, typ, id, exp, dim));
                 break;
             }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[30] = jj_gen;
            Token lookahead = getToken(1);
            boolean canSkip = !opt.requireSemicolon() && level.equals(DeclType.REPL) &&
                              (lookahead.kind == ParserConstants.EOF || lookahead.image.equals("}"));
            if (!canSkip) {
              _throwParseException("Invalid variable declaration");
            }
      }
          {if (true) return list;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid variable declaration");
    }
    throw new Error("Missing return statement in function");
  }

  // Productions for Method Declaration ===========================================
  final public MethodDeclaration methodDeclaration(DeclType level) throws ParseException {
    ModifierSet mods; MethodDeclaration decl;
    try {
      mods = optionalModifiers();
      decl = unmodifiedMethodDeclaration(mods, level);
                                                                                   {if (true) return decl;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid method declaration");
    }
    throw new Error("Missing return statement in function");
  }

  final public MethodDeclaration unmodifiedMethodDeclaration(ModifierSet mods, DeclType level) throws ParseException {
    List<TypeParameter> typeParameters = null;
    TypeName typ;
    Token id;
    int dim = 0;
    List<FormalParameter> params;
    List<? extends ReferenceTypeName> exceptions = new LinkedList<ReferenceTypeName>();
    BlockStatement body = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS:
        typeParameters = typeParameters();
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      typ = resultType();
      id = jj_consume_token(IDENTIFIER);
      params = formalParameters();
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_13;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                    dim++;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        exceptions = ReferenceTypeNameList();
        break;
      default:
        jj_la1[33] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        body = block();
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          switch (level) {
            case CLASS_MEMBER:
              checkModifiers(mods, Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED, Modifier.STATIC,
                             Modifier.FINAL, Modifier.ABSTRACT, Modifier.SYNCHRONIZED, Modifier.NATIVE,
                             Modifier.STRICT);
              break;
            case INTERFACE_MEMBER:
              checkModifiers(mods, Modifier.PUBLIC, Modifier.ABSTRACT);
              break;
            case REPL:
              checkModifiers(mods, Modifier.PUBLIC, Modifier.STRICT);
              break;
            default:
              checkModifiers(mods, Modifier.STRICT);
              break;
          }
          if (lastFormalParameterIsVarArgs) mods.getFlags().add(Modifier.VARARGS);

          if (dim > 0) {
            typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
          }
          {if (true) return new MethodDeclaration(mods, Option.wrap(typeParameters), typ, id.image, params, exceptions, body,
                                       _range(mods, token));}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid method declaration");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses formal parameters of the form '(param, param, ...)'
   * @see koala.dynamicjava.tree.FormalParameter
   */
  final public List<FormalParameter> formalParameters() throws ParseException {
    List<FormalParameter> list = new LinkedList<FormalParameter>();
    FormalParameter node;
    FormalParameter lastParam = null;
    try {
      jj_consume_token(LPAREN);
            lastFormalParameterIsVarArgs = false;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case IDENTIFIER:
      case 132:
        node = formalParameter();
                                 list.add(node);
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[35] = jj_gen;
            break label_14;
          }
          jj_consume_token(COMMA);
              if (lastFormalParameterIsVarArgs) _throwParseException("Varargs parameter must be last");
          node = formalParameter();
                                     list.add(node);
        }
        break;
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
        {if (true) return list;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid formal parameters");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses one formal parameter
   * @see koala.dynamicjava.tree.FormalParameter
   */
  final public FormalParameter formalParameter() throws ParseException {
    ModifierSet mods;
    TypeName  typ;
    Token id;
    Token varargs = null;
    int   dim = 0;
    try {
      mods = optionalModifiers();
      typ = type();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR_ARGS:
        varargs = jj_consume_token(VAR_ARGS);
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
      }
      id = jj_consume_token(IDENTIFIER);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          jj_la1[38] = jj_gen;
          break label_15;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                                                                                               dim++;
      }
        checkModifiers(mods, Modifier.FINAL);
        if (dim > 0) {
          typ = new ArrayTypeName(typ, dim, false, typ.getSourceInfo());
        }
        if (varargs != null) {
          lastFormalParameterIsVarArgs = true;
          typ = new ArrayTypeName(typ, 1, true, _range(typ, varargs));
        }
        {if (true) return new FormalParameter(mods, typ, id.image, _range(mods, token));}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid formal parameter");
    }
    throw new Error("Missing return statement in function");
  }

  // Production for Initializer ===================================================

  /**
   * Parses one initializer
   * @see koala.dynamicjava.tree.Initializer
   */
  final public Initializer initializer() throws ParseException {
    Token t = null;
    BlockStatement node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATIC:
      t = jj_consume_token(STATIC);
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    node = block();
      if (t == null) {
        {if (true) return new InstanceInitializer(node, node.getSourceInfo());}
      } else {
        {if (true) return new ClassInitializer(node, _range(t, node));}
      }
    throw new Error("Missing return statement in function");
  }

  // Productions for Constructor Declaration ======================================
  final public ConstructorDeclaration constructorDeclaration() throws ParseException {
    ModifierSet mods; ConstructorDeclaration decl;
    try {
      mods = optionalModifiers();
      decl = unmodifiedConstructorDeclaration(mods);
                                                                                 {if (true) return decl;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid constructor declaration");
    }
    throw new Error("Missing return statement in function");
  }

  final public ConstructorDeclaration unmodifiedConstructorDeclaration(ModifierSet mods) throws ParseException {
    List<TypeParameter>   typeParameters = null;
    Token                 id;
    List<FormalParameter> params;
    List<? extends ReferenceTypeName> exceptions = new LinkedList<ReferenceTypeName>();
    ConstructorCall ci = null;
    List<Node> stmt;
    LinkedList<Node> stmts = new LinkedList<Node>();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS:
        typeParameters = typeParameters();
        break;
      default:
        jj_la1[40] = jj_gen;
        ;
      }
      id = jj_consume_token(IDENTIFIER);
      params = formalParameters();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        exceptions = ReferenceTypeNameList();
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      label_16:
      while (true) {
        if (jj_2_17(1)) {
          ;
        } else {
          break label_16;
        }
        stmt = blockStatement();
                                  stmts.addAll(stmt);
      }
      jj_consume_token(RBRACE);
          // check for a constructor call ExpressionStatement
          if (!stmts.isEmpty()) {
            Node first = stmts.getFirst();
            if (first instanceof ExpressionStatement) {
              Expression exp = ((ExpressionStatement) first).getExpression();
              if (exp instanceof ConstructorCall) {
                ci = (ConstructorCall) exp;
                stmts.removeFirst();
              }
            }
          }
          checkModifiers(mods, Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED);
          if (lastFormalParameterIsVarArgs) mods.getFlags().add(Modifier.VARARGS);
          {if (true) return new ConstructorDeclaration(mods, Option.wrap(typeParameters), id.image, params, exceptions, ci, stmts,
                                            _range(mods, token));}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid constructor declaration");
    }
    throw new Error("Missing return statement in function");
  }

  // Productions for Interfaces ///////////////////////////////////////////////////

  /**
   * Parses a interface declaration
   * @see koala.dynamicjava.tree.InterfaceDeclaration
   */
  final public InterfaceDeclaration interfaceDeclaration(DeclType level) throws ParseException {
    ModifierSet mods; InterfaceDeclaration decl;
    try {
      mods = optionalModifiers();
      decl = unmodifiedInterfaceDeclaration(mods, level);
                                                                                      {if (true) return decl;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid interface declaration");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a interface declaration without modifier
   * @see koala.dynamicjava.tree.InterfaceDeclaration
   */
  final public InterfaceDeclaration unmodifiedInterfaceDeclaration(ModifierSet mods, DeclType level) throws ParseException {
    Token id;
    Token isAnnotation = null;
    List<TypeParameter> typeParameters = null;
    List<? extends ReferenceTypeName> impl = null;
    List<Node> list = new LinkedList<Node>();
    List<Node>  decl;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 132:
        isAnnotation = jj_consume_token(132);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
      jj_consume_token(INTERFACE);
      id = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS:
        typeParameters = typeParameters();
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        jj_consume_token(EXTENDS);
        impl = ReferenceTypeNameList();
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case IDENTIFIER:
        case SEMICOLON:
        case LESS:
        case 132:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_17;
        }
        decl = interfaceMemberDeclaration();
                                              list.addAll(decl);
      }
      jj_consume_token(RBRACE);
          switch (level) {
            case TOP: checkModifiers(mods, Modifier.PUBLIC, Modifier.ABSTRACT, Modifier.STRICT); break;
            case CLASS_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.PRIVATE, Modifier.PROTECTED,
                                              Modifier.STATIC, Modifier.ABSTRACT, Modifier.STRICT); break;
            case INTERFACE_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.STATIC,
                                                  Modifier.ABSTRACT, Modifier.STRICT); break;
            case LOCAL: checkModifiers(mods, Modifier.ABSTRACT, Modifier.STRICT); break;
            case REPL: checkModifiers(mods, Modifier.PUBLIC, Modifier.ABSTRACT, Modifier.STRICT); break;
          }

        {if (true) return new InterfaceDeclaration(mods, isAnnotation != null, id.image, Option.wrap(typeParameters), impl, list,
                                        _range(mods, token));}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid interface declaration");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses one declaration in the body of an interface.
   * @return a list of node because one field declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  final public List<Node> interfaceMemberDeclaration() throws ParseException {
    ModifierSet mods;
    Node node = null;
    List<Node> list = new LinkedList<Node>();
    try {
      mods = optionalModifiers();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
      case ENUM:
      case INTERFACE:
      case 132:
        node = unmodifiedTypeDeclaration(mods, DeclType.INTERFACE_MEMBER);
        break;
      default:
        jj_la1[46] = jj_gen;
        if (jj_2_18(2147483647)) {
          node = unmodifiedMethodDeclaration(mods, DeclType.INTERFACE_MEMBER);
        } else if (jj_2_19(2147483647)) {
          list = unmodifiedVariableDeclaration(mods, DeclType.INTERFACE_MEMBER);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            jj_consume_token(SEMICOLON);
            break;
          default:
            jj_la1[47] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
        if (node != null) { list.add(node); }
        {if (true) return list;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid interface member declaration");
    }
    throw new Error("Missing return statement in function");
  }

  // Productions for Enums ////////////////////////////////////////////////////////

  /**
   * Parses an enum declaration
   * @see koala.dynamicjava.tree.EnumDeclaration
   */
  final public EnumDeclaration enumDeclaration(DeclType level) throws ParseException {
    ModifierSet mods; EnumDeclaration decl;
    try {
      mods = optionalModifiers();
      decl = unmodifiedEnumDeclaration(mods, level);
                                                                                 {if (true) return decl;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid enum declaration");
    }
    throw new Error("Missing return statement in function");
  }

  final public EnumDeclaration unmodifiedEnumDeclaration(ModifierSet mods, DeclType level) throws ParseException {
    Token id;
    List<? extends ReferenceTypeName> impl = null;
    EnumDeclaration.EnumBody body;
    jj_consume_token(ENUM);
    id = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTS:
      jj_consume_token(IMPLEMENTS);
      impl = ReferenceTypeNameList();
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    jj_consume_token(LBRACE);
    body = enumBody();
    jj_consume_token(RBRACE);
      switch (level) {
        case TOP: checkModifiers(mods, Modifier.PUBLIC, Modifier.STRICT); break;
        case CLASS_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.PROTECTED, Modifier.PRIVATE,
                                          Modifier.STATIC, Modifier.STRICT); break;
        case INTERFACE_MEMBER: checkModifiers(mods, Modifier.PUBLIC, Modifier.STATIC, Modifier.STRICT); break;
        case LOCAL: checkModifiers(mods, Modifier.STRICT); break;
        case REPL: checkModifiers(mods, Modifier.PUBLIC, Modifier.STRICT); break;
      }
      {if (true) return new EnumDeclaration(mods, id.image, impl, body, _range(mods, token));}
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses the body of an enum
   * @see koala.dynamicjava.tree.Node
   */
  final public EnumDeclaration.EnumBody enumBody() throws ParseException {
    List<EnumDeclaration.EnumConstant> consts = null;
    List<Node> decls = new LinkedList<Node>();
    List<Node> ns;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
    case FINAL:
    case NATIVE:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case STATIC:
    case STRICTFP:
    case SYNCHRONIZED:
    case TRANSIENT:
    case VOLATILE:
    case IDENTIFIER:
    case 132:
      consts = enumConstants();
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ABSTRACT:
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case CLASS:
        case DOUBLE:
        case ENUM:
        case FINAL:
        case FLOAT:
        case INT:
        case INTERFACE:
        case LONG:
        case NATIVE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SHORT:
        case STATIC:
        case STRICTFP:
        case SYNCHRONIZED:
        case TRANSIENT:
        case VOID:
        case VOLATILE:
        case IDENTIFIER:
        case LBRACE:
        case SEMICOLON:
        case LESS:
        case 132:
          ;
          break;
        default:
          jj_la1[50] = jj_gen;
          break label_18;
        }
        ns = classBodyDeclaration();
                                         decls.addAll(ns);
      }
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
      {if (true) return new EnumDeclaration.EnumBody((consts==null) ? new LinkedList<EnumDeclaration.EnumConstant>() : consts,
                                          decls);}
    throw new Error("Missing return statement in function");
  }

  final public List<EnumDeclaration.EnumConstant> enumConstants() throws ParseException {
    List<EnumDeclaration.EnumConstant> list = new LinkedList<EnumDeclaration.EnumConstant>();
    EnumDeclaration.EnumConstant c;
    c = enumConstant();
                         list.add(c);
    label_19:
    while (true) {
      if (jj_2_20(3)) {
        ;
      } else {
        break label_19;
      }
      jj_consume_token(COMMA);
      c = enumConstant();
                                            list.add(c);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[52] = jj_gen;
      ;
    }
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public EnumDeclaration.EnumConstant enumConstant() throws ParseException {
    ModifierSet mods;
    Token id;
    List<Expression> args = null;
    List<Node> body = null;
    mods = optionalModifiers();
    id = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      args = arguments();
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      body = classBody();
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
      checkModifiers(mods); // can only have annotations
      {if (true) return new EnumDeclaration.EnumConstant(mods, id.image, args, body, _range(mods, token));}
    throw new Error("Missing return statement in function");
  }

  // Productions for Arrays ////////////////////////////////////////////////////////

  /**
   * Parses an array initializer
   * @see koala.dynamicjava.tree.ArrayInitializer
   */
  final public ArrayInitializer arrayInitializer() throws ParseException {
    Expression init;
    Token      t = null, b, e;
    List<Expression> list = new LinkedList<Expression>();
    b = jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case LESS:
    case BANG:
    case TILDE:
    case INCREMENT:
    case DECREMENT:
    case PLUS:
    case MINUS:
      init = variableInitializer();
               list.add(init);
      label_20:
      while (true) {
        if (jj_2_21(2)) {
          ;
        } else {
          break label_20;
        }
        jj_consume_token(COMMA);
        init = variableInitializer();
                list.add(init);
      }
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      t = jj_consume_token(COMMA);
      break;
    default:
      jj_la1[56] = jj_gen;
      ;
    }
    e = jj_consume_token(RBRACE);
             {if (true) return new ArrayInitializer(list, _range(b, e));}
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a variable initializer (ie. an expression or an array initializer)
   * @see koala.dynamicjava.tree.Expression
   */
  final public Expression variableInitializer() throws ParseException {
    Expression exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      exp = arrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LESS:
    case BANG:
    case TILDE:
    case INCREMENT:
    case DECREMENT:
    case PLUS:
    case MINUS:
      exp = expression();
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  // Productions for Blocks And Statements ////////////////////////////////////////////

  /**
   * Parses a block
   * @see koala.dynamicjava.tree.BlockStatement
   */
  final public BlockStatement block() throws ParseException {
    Token p1;
    Token p2;
    List<Node> nodes;
    List<Node> list = new LinkedList<Node>();
    try {
      p1 = jj_consume_token(LBRACE);
      label_21:
      while (true) {
        if (jj_2_22(1)) {
          ;
        } else {
          break label_21;
        }
        nodes = blockStatement();
        list.addAll(nodes);
      }
      p2 = jj_consume_token(RBRACE);
        {if (true) return new BlockStatement(list, _range(p1, p2));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid block statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses one block statement.
   * @return a list of node because one variable declaration can
   *         contain multiple declarations.
   * @see koala.dynamicjava.tree.Node
   */
  final public List<Node> blockStatement() throws ParseException {
    ModifierSet mods; Node node = null; List<Node> nodes = null;
    try {
      if (jj_2_26(2)) {
        node = keywordStatement(true);
      } else if (jj_2_27(2)) {
        mods = modifiers();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
        case ENUM:
        case INTERFACE:
        case 132:
          node = unmodifiedTypeDeclaration(mods, DeclType.LOCAL);
          break;
        default:
          jj_la1[58] = jj_gen;
          if (jj_2_23(2147483647)) {
            nodes = unmodifiedVariableDeclaration(mods, DeclType.LOCAL);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      } else if (jj_2_28(1)) {
        mods = noModifiers();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLASS:
        case ENUM:
        case INTERFACE:
        case 132:
          node = unmodifiedTypeDeclaration(mods, DeclType.LOCAL);
          break;
        default:
          jj_la1[59] = jj_gen;
          if (jj_2_24(2147483647)) {
            nodes = unmodifiedVariableDeclaration(mods, DeclType.LOCAL);
          } else if (jj_2_25(1)) {
            node = nonKeywordStatement(true);
          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
        {if (true) return (node != null) ? Collections.singletonList(node) : nodes;}
    } catch (ParseException pe) {
      _throwParseException(pe, "Invalid block statement");
    }
    throw new Error("Missing return statement in function");
  }

  final public Node statement(boolean strictExpressions) throws ParseException {
    Node node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSERT:
    case BREAK:
    case CONTINUE:
    case DO:
    case FOR:
    case IF:
    case RETURN:
    case SWITCH:
    case SYNCHRONIZED:
    case THROW:
    case TRY:
    case WHILE:
    case LBRACE:
    case SEMICOLON:
      node = keywordStatement(strictExpressions);
                                               {if (true) return node;}
      break;
    default:
      jj_la1[60] = jj_gen;
      if (jj_2_29(1)) {
        node = nonKeywordStatement(strictExpressions);
                                                  {if (true) return node;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  /** A statement that starts with a keyword or special delimiter. */
  final public Node keywordStatement(boolean strictExpressions) throws ParseException {
    Node node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      node = block();
      break;
    case SEMICOLON:
      node = emptyStatement();
      break;
    case IF:
      node = ifStatement();
      break;
    case ASSERT:
      node = assertStatement();
      break;
    case WHILE:
      node = whileStatement();
      break;
    case DO:
      node = doStatement();
      break;
    case SWITCH:
      node = switchStatement();
      break;
    case FOR:
      node = forStatement();
      break;
    case BREAK:
      node = breakStatement();
      break;
    case CONTINUE:
      node = continueStatement();
      break;
    case RETURN:
      node = returnStatement();
      break;
    case THROW:
      node = throwStatement();
      break;
    case SYNCHRONIZED:
      node = synchronizedStatement();
      break;
    case TRY:
      node = tryStatement();
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  /** A statement that does not begin with a keyword (and thus may need special lookahead treatment). */
  final public Node nonKeywordStatement(boolean strictExpressions) throws ParseException {
    Node node;
    if (jj_2_30(2)) {
      node = labeledStatement();
                                           {if (true) return node;}
    } else if (jj_2_31(1)) {
      node = expressionStatement(strictExpressions);
                                                  {if (true) return node;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a labeled statement
   * @see koala.dynamicjava.tree.ContinueTarget
   * @see koala.dynamicjava.tree.LabeledStatement
   */
  final public Statement labeledStatement() throws ParseException {
    Token id;
    Node  node;
    id = jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    node = statement(true);
      if (node instanceof ContinueTarget) {
        ((ContinueTarget)node).addLabel(id.image);
        {if (true) return (Statement)node;}
      } else {
        {if (true) return new LabeledStatement(id.image, node, _range(id, node));}
      }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses an empty statement
   * @see koala.dynamicjava.tree.EmptyStatement
   */
  final public EmptyStatement emptyStatement() throws ParseException {
    Token t;
    t = jj_consume_token(SEMICOLON);
      {if (true) return new EmptyStatement(_range(t, t));}
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses an if statement
   * @see koala.dynamicjava.tree.IfThenStatement
   * @see koala.dynamicjava.tree.IfThenElseStatement
   */
  final public Statement ifStatement() throws ParseException {
    Token t;
    Expression exp;
    Node       stat1;
    Node       stat2 = null;
    try {
      t = jj_consume_token(IF);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      default:
        jj_la1[62] = jj_gen;
        _errorChar('(');
      }
      exp = expression();
      jj_consume_token(RPAREN);
      stat1 = statement(true);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        stat2 = statement(true);
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
        if (stat2 == null) {
          {if (true) return new IfThenStatement(exp, stat1, _range(t, stat1));}
        } else {
          {if (true) return new IfThenElseStatement(exp, stat1, stat2, _range(t, stat2));}
        }
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid if statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses an assert statement
   * @see koala.dynamicjava.tree.AssertStatement
   */
  final public AssertStatement assertStatement() throws ParseException {
    Token t, t2;
    Expression exp, falseString = null;
    try {
      t = jj_consume_token(ASSERT);
      exp = expression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLON:
        jj_consume_token(COLON);
        falseString = expression();
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
      t2 = optionalSemicolon();
        {if (true) return new AssertStatement(exp, falseString, _range(t, t2));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid assert statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a while statement
   * @see koala.dynamicjava.tree.WhileStatement
   */
  final public WhileStatement whileStatement() throws ParseException {
    Token      t;
    Expression exp;
    Node       stat;
    try {
      t = jj_consume_token(WHILE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      default:
        jj_la1[65] = jj_gen;
        _errorChar('(');
      }
      exp = expression();
      jj_consume_token(RPAREN);
      stat = statement(true);
        {if (true) return new WhileStatement(exp, stat, _range(t, stat));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid while statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a do statement
   * @see koala.dynamicjava.tree.DoStatement
   */
  final public DoStatement doStatement() throws ParseException {
    Token      t1, t2;
    Expression exp;
    Node       stat;
    try {
      t1 = jj_consume_token(DO);
      stat = statement(true);
      jj_consume_token(WHILE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      default:
        jj_la1[66] = jj_gen;
        _errorChar('(');
      }
      exp = expression();
      jj_consume_token(RPAREN);
      t2 = optionalSemicolon();
        {if (true) return new DoStatement(exp, stat, _range(t1, t2));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid do statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a switch statement
   * @see koala.dynamicjava.tree.SwitchStatement
   */
  final public SwitchStatement switchStatement() throws ParseException {
    Token b, e;
    Expression sel;
    SwitchBlock sb;
    List<SwitchBlock> cases = new LinkedList<SwitchBlock>();
    try {
      b = jj_consume_token(SWITCH);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      default:
        jj_la1[67] = jj_gen;
        _errorChar('(');
      }
      sel = expression();
      jj_consume_token(RPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        jj_consume_token(LBRACE);
        break;
      default:
        jj_la1[68] = jj_gen;
        _errorChar('{');
      }
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
        case _DEFAULT:
          ;
          break;
        default:
          jj_la1[69] = jj_gen;
          break label_22;
        }
        sb = switchBlock();
                               cases.add(sb);
      }
      e = jj_consume_token(RBRACE);
          {if (true) return new SwitchStatement(sel, cases, _range(b, e));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid switch statement");
    }
    throw new Error("Missing return statement in function");
  }

  final public SwitchBlock switchBlock() throws ParseException {
    Token t, t2;
    Expression val = null;
    List<Node> stat;
    List<Node> allStats = new LinkedList<Node>();
    SourceInfo si;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE:
      t = jj_consume_token(CASE);
      val = expression();
      break;
    case _DEFAULT:
      t = jj_consume_token(_DEFAULT);
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      t2 = jj_consume_token(COLON);
                 si = _range(t, t2);
      break;
    default:
      jj_la1[71] = jj_gen;
      _errorChar(':');
                                                           si = _range(t, t);
    }
    label_23:
    while (true) {
      if (jj_2_32(1)) {
        ;
      } else {
        break label_23;
      }
      stat = blockStatement();
        allStats.addAll(stat);
        if (stat.size() > 0)
          si = _range(si, stat.get(stat.size()-1).getSourceInfo());
    }
      {if (true) return new SwitchBlock(val, (allStats.isEmpty()) ? null: allStats, si);}
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a for statement (with standard or foreach syntax)
   * @see koala.dynamicjava.tree.ForStatement
   * Modified by Adam Wulf and David Peters
   * March 2004: Dr. Java team.
   * @see koala.dynamicjava.tree.ForSlashEachStatement
   * @see koala.dynamicjava.tree.ForEachStatement
   */
  final public ForSlashEachStatement forStatement() throws ParseException {
    Token start;
    ModifierSet mods;
    FormalParameter param = null;
    List<Node> init = null;
    Expression exp = null;
    List<Node> update = null;
    Node stmt;
    try {
      start = jj_consume_token(FOR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      default:
        jj_la1[72] = jj_gen;
        _errorChar('(');
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
      case 132:
        mods = modifiers();
        if (jj_2_33(2147483647)) {
          param = forEachParameter(mods);
          jj_consume_token(COLON);
          exp = expression();
        } else if (jj_2_34(2147483647)) {
          init = unmodifiedVariableDeclaration(mods, DeclType.LOCAL);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case SEMICOLON:
      case LESS:
      case INCREMENT:
      case DECREMENT:
        mods = noModifiers();
        if (jj_2_35(2147483647)) {
          param = forEachParameter(mods);
          jj_consume_token(COLON);
          exp = expression();
        } else if (jj_2_36(2147483647)) {
          init = unmodifiedVariableDeclaration(mods, DeclType.LOCAL);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BOOLEAN:
          case BYTE:
          case CHAR:
          case DOUBLE:
          case FALSE:
          case FLOAT:
          case INT:
          case LONG:
          case NEW:
          case NULL:
          case SHORT:
          case SUPER:
          case THIS:
          case TRUE:
          case VOID:
          case INTEGER_LITERAL:
          case LONG_LITERAL:
          case FLOAT_LITERAL:
          case DOUBLE_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case IDENTIFIER:
          case LPAREN:
          case LESS:
          case INCREMENT:
          case DECREMENT:
            init = expressionStatementList();
            jj_consume_token(SEMICOLON);
            break;
          case SEMICOLON:
            jj_consume_token(SEMICOLON);
            break;
          default:
            jj_la1[73] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (param == null) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOAT_LITERAL:
        case DOUBLE_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LESS:
        case BANG:
        case TILDE:
        case INCREMENT:
        case DECREMENT:
        case PLUS:
        case MINUS:
          exp = expression();
          break;
        default:
          jj_la1[75] = jj_gen;
          ;
        }
        jj_consume_token(SEMICOLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOAT_LITERAL:
        case DOUBLE_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LESS:
        case INCREMENT:
        case DECREMENT:
          update = expressionStatementList();
          break;
        default:
          jj_la1[76] = jj_gen;
          ;
        }
      } else {
        ;
      }
      jj_consume_token(RPAREN);
      stmt = statement(true);
        if (param == null) {
          {if (true) return new ForStatement(init, exp, update, stmt, _range(start, stmt));}
        }
        else {
          {if (true) return new ForEachStatement(param, exp, stmt, _range(start, stmt));}
        }
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid for statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * A for-each parameter, which is more restricted than a general formal parameter (no additional array 
   * brackets, and no varargs)
   */
  final public FormalParameter forEachParameter(ModifierSet mods) throws ParseException {
    TypeName typ; Token id; Expression exp;
    typ = type();
    id = jj_consume_token(IDENTIFIER);
        checkModifiers(mods, Modifier.FINAL);
        {if (true) return new FormalParameter(mods, typ, id.image, _range(mods, id));}
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a comma separated list of strict ExpressionStatements
   */
  final public List<Node> expressionStatementList() throws ParseException {
    List<Node> list = new LinkedList<Node>(); Expression exp;
    exp = statementExpression();
      list.add(new ExpressionStatement(exp, true, exp.getSourceInfo()));
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[77] = jj_gen;
        break label_24;
      }
      jj_consume_token(COMMA);
      exp = statementExpression();
         list.add(new ExpressionStatement(exp, true, exp.getSourceInfo()));
    }
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a break statement
   * @see koala.dynamicjava.tree.BreakStatement
   */
  final public BreakStatement breakStatement() throws ParseException {
    Token b, e;
    Token id = null;
    try {
      b = jj_consume_token(BREAK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        id = jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[78] = jj_gen;
        ;
      }
      e = jj_consume_token(SEMICOLON);
        {if (true) return new BreakStatement((id != null) ? id.image : null, _range(b, e));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid break statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a continue statement
   * @see koala.dynamicjava.tree.ContinueStatement
   */
  final public ContinueStatement continueStatement() throws ParseException {
    Token b, e;
    Token id = null;
    try {
      b = jj_consume_token(CONTINUE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        id = jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      e = jj_consume_token(SEMICOLON);
        {if (true) return new ContinueStatement((id != null) ? id.image : null, _range(b, e));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid continue statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a return statement
   * @see koala.dynamicjava.tree.ReturnStatement
   */
  final public ReturnStatement returnStatement() throws ParseException {
    Token b, e;
    Expression exp = null;
    try {
      b = jj_consume_token(RETURN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LESS:
      case BANG:
      case TILDE:
      case INCREMENT:
      case DECREMENT:
      case PLUS:
      case MINUS:
        exp = expression();
        break;
      default:
        jj_la1[80] = jj_gen;
        ;
      }
      e = optionalSemicolon();
        {if (true) return new ReturnStatement(exp, _range(b, e));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid return statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a throw statement
   * @see koala.dynamicjava.tree.ThrowStatement
   */
  final public ThrowStatement throwStatement() throws ParseException {
    Token b, e;
    Expression exp;
    try {
      b = jj_consume_token(THROW);
      exp = expression();
      e = optionalSemicolon();
        {if (true) return new ThrowStatement(exp, _range(b, e));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid throw statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a synchronized statement
   * @see koala.dynamicjava.tree.SynchronizedStatement
   */
  final public SynchronizedStatement synchronizedStatement() throws ParseException {
    Token      t;
    Expression exp;
    Node       stmt;
    try {
      t = jj_consume_token(SYNCHRONIZED);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      default:
        jj_la1[81] = jj_gen;
        _errorChar('(');
      }
      exp = expression();
      jj_consume_token(RPAREN);
      stmt = block();
          {if (true) return new SynchronizedStatement(exp, stmt, _range(t, stmt));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid synchronized statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses a try statement
   * @see koala.dynamicjava.tree.TryStatement
   */
  final public TryStatement tryStatement() throws ParseException {
    Token           t, u;
    Node            tryBlock;
    Node            catchBlock;
    List<CatchStatement>      catches = new LinkedList<CatchStatement>();
    FormalParameter formal;
    Node            finallyBlock = null;
    try {
      t = jj_consume_token(TRY);
      tryBlock = block();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CATCH:
          ;
          break;
        default:
          jj_la1[82] = jj_gen;
          break label_25;
        }
        u = jj_consume_token(CATCH);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          break;
        default:
          jj_la1[83] = jj_gen;
          _errorChar('(');
        }
        formal = formalParameter();
        jj_consume_token(RPAREN);
        catchBlock = block();
            catches.add(new CatchStatement(formal, catchBlock, _range(u, catchBlock)));
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINALLY:
        jj_consume_token(FINALLY);
        finallyBlock = block();
        break;
      default:
        jj_la1[84] = jj_gen;
        ;
      }
          if (finallyBlock == null && catches.size() == 0) {
            {if (true) throw new ParseError(reader.getMessage("try.without.catch", null), _range(t, t));}
          }
          {if (true) return new TryStatement(tryBlock, catches, finallyBlock, _range(t, token));}
    } catch (ParseException pe) {
      _throwParseException(pe,"Invalid try statement");
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Parses an ExpressionStatement; if strictExpression is true,
   * a trailing semicolon is required and only StatementExpressions
   * will be allowed.
   */
  final public ExpressionStatement expressionStatement(boolean strictExpression) throws ParseException {
    Expression exp; Token t = null;
      lookaheadFlag = strictExpression;
    if (lookaheadFlag) {
      exp = statementExpression();
      t = jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LESS:
      case BANG:
      case TILDE:
      case INCREMENT:
      case DECREMENT:
      case PLUS:
      case MINUS:
        exp = expression();
        if (jj_2_37(2147483647)) {

        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SEMICOLON:
            t = jj_consume_token(SEMICOLON);
            break;
          default:
            jj_la1[85] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[86] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return new ExpressionStatement(exp, t != null, _range(exp, token));}
    throw new Error("Missing return statement in function");
  }

  final public Token optionalSemicolon() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      t = jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[87] = jj_gen;
      if (!opt.requireSemicolon()) {
        t = jj_consume_token(0);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  // Productions for Expressions /////////////////////////////////////////////////////////

  /**
   * Parses an expression
   * @see koala.dynamicjava.tree.Expression
   */
  final public Expression expression() throws ParseException {
    Expression exp;
    exp = conditionalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
    case PLUS_ASSIGN:
    case MINUS_ASSIGN:
    case STAR_ASSIGN:
    case SLASH_ASSIGN:
    case AND_ASSIGN:
    case OR_ASSIGN:
    case XOR_ASSIGN:
    case REMAINDER_ASSIGN:
    case LEFT_SHIFT_ASSIGN:
    case RIGHT_SIGNED_SHIFT_ASSIGN:
    case RIGHT_UNSIGNED_SHIFTASSIGN:
      exp = expressionSuffix(exp);
      break;
    default:
      jj_la1[88] = jj_gen;
      ;
    }
      {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Parse only an expression that can appear as a statement
   */
  final public Expression statementExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    Expression exp3 = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCREMENT:
      exp = preIncrementExpression();
      break;
    case DECREMENT:
      exp = preDecrementExpression();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LESS:
      exp = primaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
      case INCREMENT:
      case DECREMENT:
      case PLUS_ASSIGN:
      case MINUS_ASSIGN:
      case STAR_ASSIGN:
      case SLASH_ASSIGN:
      case AND_ASSIGN:
      case OR_ASSIGN:
      case XOR_ASSIGN:
      case REMAINDER_ASSIGN:
      case LEFT_SHIFT_ASSIGN:
      case RIGHT_SIGNED_SHIFT_ASSIGN:
      case RIGHT_UNSIGNED_SHIFTASSIGN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INCREMENT:
          jj_consume_token(INCREMENT);
            exp = new PostIncrement(exp, _range(exp, token));
          break;
        case DECREMENT:
          jj_consume_token(DECREMENT);
            exp = new PostDecrement(exp, _range(exp, token));
          break;
        case ASSIGN:
        case PLUS_ASSIGN:
        case MINUS_ASSIGN:
        case STAR_ASSIGN:
        case SLASH_ASSIGN:
        case AND_ASSIGN:
        case OR_ASSIGN:
        case XOR_ASSIGN:
        case REMAINDER_ASSIGN:
        case LEFT_SHIFT_ASSIGN:
        case RIGHT_SIGNED_SHIFT_ASSIGN:
        case RIGHT_UNSIGNED_SHIFTASSIGN:
          exp = expressionSuffix(exp);
          break;
        default:
          jj_la1[89] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[90] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[91] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          if (exp instanceof StatementExpression) {
            {if (true) return exp;}
          } else {
            {if (true) throw new ParseError(reader.getMessage("expression.statement", null), exp.getSourceInfo());}
          }
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression expressionSuffix(Expression pre) throws ParseException {
    Expression exp2;
    Expression exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      exp2 = expression();
      exp = new SimpleAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case STAR_ASSIGN:
      jj_consume_token(STAR_ASSIGN);
      exp2 = expression();
       exp = new MultiplyAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case SLASH_ASSIGN:
      jj_consume_token(SLASH_ASSIGN);
      exp2 = expression();
       exp = new DivideAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case REMAINDER_ASSIGN:
      jj_consume_token(REMAINDER_ASSIGN);
      exp2 = expression();
       exp = new RemainderAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case PLUS_ASSIGN:
      jj_consume_token(PLUS_ASSIGN);
      exp2 = expression();
       exp = new AddAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case MINUS_ASSIGN:
      jj_consume_token(MINUS_ASSIGN);
      exp2 = expression();
       exp = new SubtractAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case LEFT_SHIFT_ASSIGN:
      jj_consume_token(LEFT_SHIFT_ASSIGN);
      exp2 = expression();
       exp = new ShiftLeftAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case RIGHT_SIGNED_SHIFT_ASSIGN:
      jj_consume_token(RIGHT_SIGNED_SHIFT_ASSIGN);
      exp2 = expression();
       exp = new ShiftRightAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case RIGHT_UNSIGNED_SHIFTASSIGN:
      jj_consume_token(RIGHT_UNSIGNED_SHIFTASSIGN);
      exp2 = expression();
       exp = new UnsignedShiftRightAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case AND_ASSIGN:
      jj_consume_token(AND_ASSIGN);
      exp2 = expression();
       exp = new BitAndAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case XOR_ASSIGN:
      jj_consume_token(XOR_ASSIGN);
      exp2 = expression();
       exp = new ExclusiveOrAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    case OR_ASSIGN:
      jj_consume_token(OR_ASSIGN);
      exp2 = expression();
       exp = new BitOrAssignExpression(pre, exp2, _range(pre, exp2));
      break;
    default:
      jj_la1[92] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
       if (!(pre instanceof LeftHandSide)) {
         {if (true) throw new ParseError(reader.getMessage("left.expression.in.assignment",
                                                null),
                              pre.getSourceInfo());}
       }
       {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression conditionalExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    Expression exp3;
    exp = conditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      jj_consume_token(HOOK);
      exp2 = expression();
      jj_consume_token(COLON);
      exp3 = conditionalExpression();
      exp = new ConditionalExpression(exp, exp2, exp3, _range(exp, exp3));
      break;
    default:
      jj_la1[93] = jj_gen;
      ;
    }
         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression conditionalOrExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = conditionalAndExpression();
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONDITIONAL_OR:
        ;
        break;
      default:
        jj_la1[94] = jj_gen;
        break label_26;
      }
      jj_consume_token(CONDITIONAL_OR);
      exp2 = conditionalAndExpression();
      exp = new OrExpression(exp, exp2, _range(exp, exp2));
    }
      {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression conditionalAndExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = inclusiveOrExpression();
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONDITIONAL_AND:
        ;
        break;
      default:
        jj_la1[95] = jj_gen;
        break label_27;
      }
      jj_consume_token(CONDITIONAL_AND);
      exp2 = inclusiveOrExpression();
      exp = new AndExpression(exp, exp2, _range(exp, exp2));
    }
      {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression inclusiveOrExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = exclusiveOrExpression();
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BITWISE_OR:
        ;
        break;
      default:
        jj_la1[96] = jj_gen;
        break label_28;
      }
      jj_consume_token(BITWISE_OR);
      exp2 = exclusiveOrExpression();
      exp = new BitOrExpression(exp, exp2, _range(exp, exp2));
    }
      {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression exclusiveOrExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = andExpression();
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        jj_la1[97] = jj_gen;
        break label_29;
      }
      jj_consume_token(XOR);
      exp2 = andExpression();
           exp = new ExclusiveOrExpression(exp, exp2, _range(exp, exp2));
    }
      {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression andExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = equalityExpression();
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BITWISE_AND:
        ;
        break;
      default:
        jj_la1[98] = jj_gen;
        break label_30;
      }
      jj_consume_token(BITWISE_AND);
      exp2 = equalityExpression();
      exp = new BitAndExpression(exp, exp2, _range(exp, exp2));
    }
      {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression equalityExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = instanceOfExpression();
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case NOT_EQUAL:
        ;
        break;
      default:
        jj_la1[99] = jj_gen;
        break label_31;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        jj_consume_token(EQUAL);
        exp2 = instanceOfExpression();
      exp = new EqualExpression(exp, exp2, _range(exp, exp2));
        break;
      case NOT_EQUAL:
        jj_consume_token(NOT_EQUAL);
        exp2 = instanceOfExpression();
         exp = new NotEqualExpression(exp, exp2, _range(exp, exp2));
        break;
      default:
        jj_la1[100] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression instanceOfExpression() throws ParseException {
    Expression exp;
    TypeName       typ = null;
    exp = relationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      jj_consume_token(INSTANCEOF);
      typ = type();
      break;
    default:
      jj_la1[101] = jj_gen;
      ;
    }
      if (typ != null) { {if (true) return new InstanceOfExpression(exp, typ, _range(exp, typ));} }
      else { {if (true) return exp;} }
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression relationalExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = shiftExpression();
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GREATER_THAN:
      case LESS:
      case LESS_OR_EQUAL:
      case GREATER_OR_EQUAL:
        ;
        break;
      default:
        jj_la1[102] = jj_gen;
        break label_32;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LESS:
        jj_consume_token(LESS);
        exp2 = shiftExpression();
            exp = new LessExpression(exp, exp2, _range(exp, exp2));
        break;
      case GREATER_THAN:
        jj_consume_token(GREATER_THAN);
        exp2 = shiftExpression();
         exp = new GreaterExpression(exp, exp2, _range(exp, exp2));
        break;
      case LESS_OR_EQUAL:
        jj_consume_token(LESS_OR_EQUAL);
        exp2 = shiftExpression();
         exp = new LessOrEqualExpression(exp, exp2, _range(exp, exp2));
        break;
      case GREATER_OR_EQUAL:
        jj_consume_token(GREATER_OR_EQUAL);
        exp2 = shiftExpression();
         exp = new GreaterOrEqualExpression(exp, exp2, _range(exp, exp2));
        break;
      default:
        jj_la1[103] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression shiftExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = additiveExpression();
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_SHIFT:
      case RSSHIFT1:
      case RUSHIFT1:
        ;
        break;
      default:
        jj_la1[104] = jj_gen;
        break label_33;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEFT_SHIFT:
        jj_consume_token(LEFT_SHIFT);
        exp2 = additiveExpression();
      exp = new ShiftLeftExpression(exp, exp2, _range(exp, exp2));
        break;
      case RSSHIFT1:
        jj_consume_token(RSSHIFT1);
        jj_consume_token(RSSHIFT2);
        exp2 = additiveExpression();
         exp = new ShiftRightExpression(exp, exp2, _range(exp, exp2));
        break;
      case RUSHIFT1:
        jj_consume_token(RUSHIFT1);
        jj_consume_token(RUSHIFT2);
        jj_consume_token(RUSHIFT3);
        exp2 = additiveExpression();
         exp = new UnsignedShiftRightExpression(exp, exp2, _range(exp, exp2));
        break;
      default:
        jj_la1[105] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression additiveExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = multiplicativeExpression();
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[106] = jj_gen;
        break label_34;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
        exp2 = multiplicativeExpression();
           exp = new AddExpression(exp, exp2, _range(exp, exp2));
        break;
      case MINUS:
        jj_consume_token(MINUS);
        exp2 = multiplicativeExpression();
           exp = new SubtractExpression(exp, exp2, _range(exp, exp2));
        break;
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression multiplicativeExpression() throws ParseException {
    Expression exp;
    Expression exp2;
    exp = unaryExpression();
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
      case REMAINDER:
        ;
        break;
      default:
        jj_la1[108] = jj_gen;
        break label_35;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
        exp2 = unaryExpression();
      exp = new MultiplyExpression(exp, exp2, _range(exp, exp2));
        break;
      case SLASH:
        jj_consume_token(SLASH);
        exp2 = unaryExpression();
         exp = new DivideExpression(exp, exp2, _range(exp, exp2));
        break;
      case REMAINDER:
        jj_consume_token(REMAINDER);
        exp2 = unaryExpression();
         exp = new RemainderExpression(exp, exp2, _range(exp, exp2));
        break;
      default:
        jj_la1[109] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression unaryExpression() throws ParseException {
    Expression exp = null;
    Token      t,tk;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      t = jj_consume_token(PLUS);
      exp = unaryExpression();
          {if (true) return new PlusExpression(exp, _range(t, exp));}
      break;
    case MINUS:
      t = jj_consume_token(MINUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        tk = jj_consume_token(INTEGER_LITERAL);
               try { {if (true) return new IntegerLiteral("-"+tk.image, _range(t, tk));} }
               catch (NumberFormatException e) { {if (true) throw new ParseError(e, _range(t, tk));} }
        break;
      case LONG_LITERAL:
        tk = jj_consume_token(LONG_LITERAL);
               if(tk.image.endsWith("L")) tk.image=tk.image.substring(0,tk.image.length()-1);
               try { {if (true) return new LongLiteral("-"+tk.image, _range(t, tk));} }
               catch (NumberFormatException e) { {if (true) throw new ParseError(e, _range(t, tk));} }
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case SUPER:
      case THIS:
      case TRUE:
      case VOID:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LESS:
      case BANG:
      case TILDE:
      case INCREMENT:
      case DECREMENT:
      case PLUS:
      case MINUS:
        exp = unaryExpression();
               {if (true) return new MinusExpression(exp, _range(t, exp));}
        break;
      default:
        jj_la1[110] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case INCREMENT:
      exp = preIncrementExpression();
      break;
    case DECREMENT:
      exp = preDecrementExpression();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LESS:
    case BANG:
    case TILDE:
      exp = unaryExpressionNotPlusMinus();
      break;
    default:
      jj_la1[111] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression unaryExpressionNotPlusMinus() throws ParseException {
    Expression exp;
    Token      t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TILDE:
      t = jj_consume_token(TILDE);
      exp = unaryExpression();
      {if (true) return new ComplementExpression(exp, _range(t, exp));}
      break;
    case BANG:
      t = jj_consume_token(BANG);
      exp = unaryExpression();
       {if (true) return new NotExpression(exp, _range(t, exp));}
      break;
    default:
      jj_la1[112] = jj_gen;
      if (jj_2_38(2147483647)) {
        exp = castExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOAT_LITERAL:
        case DOUBLE_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LESS:
          exp = postfixExpression();
          break;
        default:
          jj_la1[113] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
       {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression castExpression() throws ParseException {
    TypeName typ; Token t; Expression exp;
    t = jj_consume_token(LPAREN);
    if (jj_2_39(2)) {
      typ = primitiveType();
      jj_consume_token(RPAREN);
      exp = unaryExpression();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        typ = type();
        jj_consume_token(RPAREN);
        exp = unaryExpressionNotPlusMinus();
        break;
      default:
        jj_la1[114] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return new CastExpression(typ, exp, _range(t, exp));}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression preIncrementExpression() throws ParseException {
    Expression pe;
    Token      t;
    t = jj_consume_token(INCREMENT);
    pe = primaryExpression();
      {if (true) return new PreIncrement(pe, _range(t, pe));}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression preDecrementExpression() throws ParseException {
    Expression pe;
    Token      t;
    t = jj_consume_token(DECREMENT);
    pe = primaryExpression();
      {if (true) return new PreDecrement(pe, _range(t, pe));}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression postfixExpression() throws ParseException {
    Expression pe;
    pe = primaryExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCREMENT:
    case DECREMENT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCREMENT:
        jj_consume_token(INCREMENT);
           {if (true) return new PostIncrement(pe, _range(pe, token));}
        break;
      case DECREMENT:
        jj_consume_token(DECREMENT);
         {if (true) return new PostDecrement(pe, _range(pe, token));}
        break;
      default:
        jj_la1[115] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[116] = jj_gen;
      ;
    }
         {if (true) return pe;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression primaryExpression() throws ParseException {
    Primary p; Option<List<TypeName>> targs; List<TypeName> targs2;
    Expression exp; List<Expression> args; List<Node> nodes;
    p = primaryPrefix();
    label_36:
    while (true) {
      if (jj_2_40(2147483647)) {
        ;
      } else {
        break label_36;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        jj_consume_token(DOT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
        case SUPER:
        case THIS:
        case IDENTIFIER:
        case LESS:
          targs = optionalTypeArguments();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            jj_consume_token(IDENTIFIER);
                             p = p.dotId(targs, token);
            break;
          case THIS:
            jj_consume_token(THIS);
                       p = p.dotThis(targs, token);
            break;
          case SUPER:
            jj_consume_token(SUPER);
                        p = p.dotSuper(targs, token);
            break;
          case NEW:
            jj_consume_token(NEW);
            jj_consume_token(IDENTIFIER);
                                   p = p.dotNew(targs, token);
            break;
          default:
            jj_la1[117] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        case CLASS:
          jj_consume_token(CLASS);
                      p = p.dotClass(token);
          break;
        default:
          jj_la1[118] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case LBRACKET:
        jj_consume_token(LBRACKET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RBRACKET:
          jj_consume_token(RBRACKET);
                  p = p.withArrayDim(token);
          break;
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOAT_LITERAL:
        case DOUBLE_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LESS:
        case BANG:
        case TILDE:
        case INCREMENT:
        case DECREMENT:
        case PLUS:
        case MINUS:
          exp = expression();
          jj_consume_token(RBRACKET);
                                   p = p.withArrayAccess(exp, token);
          break;
        default:
          jj_la1[119] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case LESS:
        targs2 = typeArguments();
            p = p.withTypeArgs(targs2, token);
        break;
      case LPAREN:
        args = arguments();
                           p = p.withArgs(args, token);
        break;
      case LBRACE:
        nodes = classBody();
                            p = p.withClassBody(nodes, token);
        break;
      default:
        jj_la1[120] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return p.asExpression();}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Primary primaryPrefix() throws ParseException {
    Token first=getToken(1); Expression exp; PrimitiveTypeName pt; List<TypeName> targs; Primary p;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      jj_consume_token(IDENTIFIER);
                   {if (true) return new AmbiguousNamePrimary(token);}
      break;
    case FALSE:
    case NULL:
    case TRUE:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      exp = literal();
                    {if (true) return new ExpressionPrimary(exp);}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      exp = expression();
      jj_consume_token(RPAREN);
                               exp.setSourceInfo(_range(first, token)); {if (true) return new ExpressionPrimary(exp);}
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
      pt = primitiveType();
                         {if (true) return new PrimitiveTypeNamePrimary(pt);}
      break;
    case VOID:
      jj_consume_token(VOID);
             {if (true) return new VoidTypeNamePrimary(new VoidTypeName(_range(token, token)));}
      break;
    case THIS:
      jj_consume_token(THIS);
             {if (true) return new ThisExpressionPrimary(token);}
      break;
    case SUPER:
      jj_consume_token(SUPER);
              {if (true) return new PartialSuperPrimary(token);}
      break;
    case LESS:
      targs = typeArguments();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
                       {if (true) return new PartialSimpleMethodCallPrimary(Option.some(targs), token, _range(first, token));}
        break;
      case THIS:
        jj_consume_token(THIS);
                 {if (true) return new PartialThisConstructorCallPrimary(Option.some(targs), _range(first, token));}
        break;
      case SUPER:
        jj_consume_token(SUPER);
                  {if (true) return new PartialSuperConstructorCallPrimary(Option.some(targs), _range(first, token));}
        break;
      default:
        jj_la1[121] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case NEW:
      p = allocation();
                     {if (true) return p;}
      break;
    default:
      jj_la1[122] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Primary allocation() throws ParseException {
    Token first; ArrayAllocation.TypeDescriptor td; TypeName primT; ReferenceTypeName refT;
    List<TypeName> typeArgs;
    first = jj_consume_token(NEW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
      primT = primitiveType();
      td = arrayDimsAndInits();
          {if (true) return new ArrayAllocationPrimary(new ArrayAllocation(primT, td, _range(first, td)));}
      break;
    case LESS:
      typeArgs = typeArguments();
      refT = referenceTypeName();
          {if (true) return new PartialSimpleAllocationPrimary(Option.some(typeArgs), refT, _range(first, refT));}
      break;
    case IDENTIFIER:
      refT = referenceTypeName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        td = arrayDimsAndInits();
            {if (true) return new ArrayAllocationPrimary(new ArrayAllocation(refT, td, _range(first, td)));}
        break;
      default:
        jj_la1[123] = jj_gen;
          {if (true) return new PartialSimpleAllocationPrimary(Option.<List<TypeName>>none(), refT, _range(first, refT));}
      }
      break;
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public ArrayAllocation.TypeDescriptor arrayDimsAndInits() throws ParseException {
    List<Expression>  dims = new LinkedList<Expression>();
    int   dim  = 0;
    Token left, right;
    Expression exp;
    ArrayInitializer ai;
    if (jj_2_43(2)) {
      label_37:
      while (true) {
        left = jj_consume_token(LBRACKET);
        exp = expression();
        right = jj_consume_token(RBRACKET);
            dims.add(exp);
        if (jj_2_41(2)) {
          ;
        } else {
          break label_37;
        }
      }
      label_38:
      while (true) {
        if (jj_2_42(2)) {
          ;
        } else {
          break label_38;
        }
        left = jj_consume_token(LBRACKET);
        right = jj_consume_token(RBRACKET);
                                            dim++;
      }
         {if (true) return new ArrayAllocation.TypeDescriptor(dims, dim+dims.size(), null, _range(left, right));}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        label_39:
        while (true) {
          left = jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
                          dim++;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            ;
            break;
          default:
            jj_la1[125] = jj_gen;
            break label_39;
          }
        }
        ai = arrayInitializer();
           {if (true) return new ArrayAllocation.TypeDescriptor(dims, dim, ai, _range(left, ai));}
        break;
      default:
        jj_la1[126] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public List<Expression> arguments() throws ParseException {
    List<Expression> list = new LinkedList<Expression>(); Expression exp;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LESS:
    case BANG:
    case TILDE:
    case INCREMENT:
    case DECREMENT:
    case PLUS:
    case MINUS:
      exp = expression();
                           list.add(exp);
      label_40:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[127] = jj_gen;
          break label_40;
        }
        jj_consume_token(COMMA);
        exp = expression();
                                 list.add(exp);
      }
      break;
    default:
      jj_la1[128] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse an expression
   */
  final public Expression literal() throws ParseException {
    Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        t = jj_consume_token(INTEGER_LITERAL);
        try { {if (true) return new IntegerLiteral(t.image, _range(t, t));} }
        catch (NumberFormatException e) { {if (true) throw new ParseError(e, _range(t, t));} }
        break;
      case LONG_LITERAL:
        t = jj_consume_token(LONG_LITERAL);
        if(t.image.endsWith("L")) t.image=t.image.substring(0,t.image.length()-1);
        try { {if (true) return new LongLiteral(t.image, _range(t, t));} }
        catch (NumberFormatException e) { {if (true) throw new ParseError(e, _range(t, t));} }
        break;
      case FLOAT_LITERAL:
        t = jj_consume_token(FLOAT_LITERAL);
        {if (true) return new FloatLiteral(t.image, _range(t, t));}
        break;
      case DOUBLE_LITERAL:
        t = jj_consume_token(DOUBLE_LITERAL);
        {if (true) return new DoubleLiteral(t.image, _range(t, t));}
        break;
      case CHARACTER_LITERAL:
        t = jj_consume_token(CHARACTER_LITERAL);
        {if (true) return new CharacterLiteral(t.image, _range(t, t));}
        break;
      case STRING_LITERAL:
        t = jj_consume_token(STRING_LITERAL);
        {if (true) return new StringLiteral(t.image, _range(t, t));}
        break;
      case TRUE:
        t = jj_consume_token(TRUE);
        {if (true) return new BooleanLiteral(true, _range(t, t));}
        break;
      case FALSE:
        t = jj_consume_token(FALSE);
        {if (true) return new BooleanLiteral(false, _range(t, t));}
        break;
      case NULL:
        t = jj_consume_token(NULL);
        {if (true) return new NullLiteral(_range(t, t));}
        break;
      default:
        jj_la1[129] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException pe) {
      _throwParseException(pe, "This is an illegal literal!");
    }
    throw new Error("Missing return statement in function");
  }

  // Productions for Types ///////////////////////////////////////////////////////////

  /**
   * Used internally to parse types
   */
  final public TypeName type() throws ParseException {
    int   dim = 0;
    TypeName  pt  = null;
    Token t   = null;
    TypeName rt = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
      pt = primitiveType();
      break;
    case IDENTIFIER:
      rt = referenceTypeName();
      break;
    default:
      jj_la1[130] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_41:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        ;
        break;
      default:
        jj_la1[131] = jj_gen;
        break label_41;
      }
      jj_consume_token(LBRACKET);
      t = jj_consume_token(RBRACKET);
      dim++;
    }
      if (pt != null) {
        rt = pt;
      }
      if (dim == 0) {
        {if (true) return rt;}
      } else {
        {if (true) return new ArrayTypeName(rt, dim, false, _range(rt, t));}
      }
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse types
   */
  final public TypeName resultType() throws ParseException {
    TypeName  typ;
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VOID:
      t = jj_consume_token(VOID);
      {if (true) return new VoidTypeName(_range(t, t));}
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      typ = type();
      {if (true) return typ;}
      break;
    default:
      jj_la1[132] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * Used internally to parse types
   */
  final public PrimitiveTypeName primitiveType() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
      t = jj_consume_token(BOOLEAN);
      {if (true) return new BooleanTypeName(_range(t, t));}
      break;
    case CHAR:
      t = jj_consume_token(CHAR);
      {if (true) return new CharTypeName(_range(t, t));}
      break;
    case BYTE:
      t = jj_consume_token(BYTE);
      {if (true) return new ByteTypeName(_range(t, t));}
      break;
    case SHORT:
      t = jj_consume_token(SHORT);
      {if (true) return new ShortTypeName(_range(t, t));}
      break;
    case INT:
      t = jj_consume_token(INT);
      {if (true) return new IntTypeName(_range(t, t));}
      break;
    case LONG:
      t = jj_consume_token(LONG);
      {if (true) return new LongTypeName(_range(t, t));}
      break;
    case FLOAT:
      t = jj_consume_token(FLOAT);
      {if (true) return new FloatTypeName(_range(t, t));}
      break;
    case DOUBLE:
      t = jj_consume_token(DOUBLE);
      {if (true) return new DoubleTypeName(_range(t, t));}
      break;
    default:
      jj_la1[133] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public List<TypeParameter> typeParameters() throws ParseException {
    List<TypeParameter> list = new LinkedList<TypeParameter>();
    TypeParameter temp;
    jj_consume_token(LESS);
    temp = typeParameter();
                               list.add(temp);
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[134] = jj_gen;
        break label_42;
      }
      jj_consume_token(COMMA);
      temp = typeParameter();
                              list.add(temp);
    }
    RightAngledBracket();
      {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public TypeParameter typeParameter() throws ParseException {
    List<IdentifierToken> name;
    TypeName bound = new ReferenceTypeName("java.lang.Object");
    List<ReferenceTypeName> interfaceBoundsList = new LinkedList<ReferenceTypeName>();
    ReferenceTypeName interf;
    name = name();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      jj_consume_token(EXTENDS);
      bound = type();
      label_43:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BITWISE_AND:
          ;
          break;
        default:
          jj_la1[135] = jj_gen;
          break label_43;
        }
        jj_consume_token(BITWISE_AND);
        interf = referenceTypeName();
              interfaceBoundsList.add(interf);
      }
      break;
    default:
      jj_la1[136] = jj_gen;
      ;
    }
      IdentifierToken first = name.get(0);
      if(bound instanceof ReferenceTypeName){
        {if (true) return new TypeParameter(name, (ReferenceTypeName)bound, interfaceBoundsList, _range(name.get(0), token));}
      } else {
        {if (true) throw new ParseError("Primitives are not allowed as bound"+
                              "types, and array types are temporarily disabled due to a "+
                              "DynamicJava AST hierarchy bug!", first.getSourceInfo());}
      }
    throw new Error("Missing return statement in function");
  }

  final public Option<List<TypeName>> optionalTypeArguments() throws ParseException {
    List<TypeName> targs = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LESS:
      targs = typeArguments();
      break;
    default:
      jj_la1[137] = jj_gen;
      ;
    }
                                {if (true) return Option.wrap(targs);}
    throw new Error("Missing return statement in function");
  }

  final public List<TypeName> typeArguments() throws ParseException {
    List<TypeName> typeArgs = new LinkedList<TypeName>();
    TypeName arg;
    jj_consume_token(LESS);
    arg = TypeArgument();
                           typeArgs.add(arg);
    label_44:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[138] = jj_gen;
        break label_44;
      }
      jj_consume_token(COMMA);
      arg = TypeArgument();
                                     typeArgs.add(arg);
    }
    RightAngledBracket();
                           {if (true) return typeArgs;}
    throw new Error("Missing return statement in function");
  }

  final public TypeName TypeArgument() throws ParseException {
    Token hook; TypeName upper = null; TypeName lower = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      hook = jj_consume_token(HOOK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        jj_consume_token(EXTENDS);
        upper = type();
        break;
      default:
        jj_la1[139] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUPER:
        jj_consume_token(SUPER);
        lower = type();
        break;
      default:
        jj_la1[140] = jj_gen;
        ;
      }
        {if (true) return new HookTypeName(Option.wrap(upper), Option.wrap(lower), _range(hook, token));}
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case IDENTIFIER:
      upper = type();
                       {if (true) return upper;}
      break;
    default:
      jj_la1[141] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Token RightAngledBracket() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GREATER_THAN:
      t = jj_consume_token(GREATER_THAN);
      break;
    case RSSHIFT1:
      t = jj_consume_token(RSSHIFT1);
      break;
    case RSSHIFT2:
      t = jj_consume_token(RSSHIFT2);
      break;
    case RUSHIFT1:
      t = jj_consume_token(RUSHIFT1);
      break;
    case RUSHIFT2:
      t = jj_consume_token(RUSHIFT2);
      break;
    case RUSHIFT3:
      t = jj_consume_token(RUSHIFT3);
      break;
    default:
      jj_la1[142] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  // Productions for Annotations /////////////////////////////////////////////////////
  final public Annotation annotation() throws ParseException {
    Token first;
    ReferenceTypeName type;
    Token id;
    Expression exp;
    List<Pair<String, Expression>> vals = new LinkedList<Pair<String, Expression>>();
    first = jj_consume_token(132);
    type = referenceTypeName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      if (jj_2_44(2)) {
        id = jj_consume_token(IDENTIFIER);
        jj_consume_token(ASSIGN);
        exp = annotationValue();
                                                                 vals.add(Pair.make(id.image, exp));
        label_45:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[143] = jj_gen;
            break label_45;
          }
          jj_consume_token(COMMA);
          id = jj_consume_token(IDENTIFIER);
          jj_consume_token(ASSIGN);
          exp = annotationValue();
                                                            vals.add(Pair.make(id.image, exp));
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case SUPER:
        case THIS:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case LONG_LITERAL:
        case FLOAT_LITERAL:
        case DOUBLE_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case LESS:
        case BANG:
        case TILDE:
        case INCREMENT:
        case DECREMENT:
        case PLUS:
        case MINUS:
        case 132:
          exp = annotationValue();
                                vals.add(Pair.make("value", exp));
          break;
        default:
          jj_la1[144] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[145] = jj_gen;
      ;
    }
      {if (true) return new Annotation(type, vals, _range(first, token));}
    throw new Error("Missing return statement in function");
  }

  final public Expression annotationValue() throws ParseException {
    Expression exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LESS:
    case BANG:
    case TILDE:
    case INCREMENT:
    case DECREMENT:
    case PLUS:
    case MINUS:
      exp = conditionalExpression();
                                  {if (true) return exp;}
      break;
    case 132:
      exp = annotation();
                       {if (true) return exp;}
      break;
    case LBRACE:
      exp = annotationArrayValue();
                                 {if (true) return exp;}
      break;
    default:
      jj_la1[146] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayInitializer annotationArrayValue() throws ParseException {
    Token first; Expression val; List<Expression> vals = new LinkedList<Expression>();
    first = jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case SUPER:
    case THIS:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case LONG_LITERAL:
    case FLOAT_LITERAL:
    case DOUBLE_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case LESS:
    case BANG:
    case TILDE:
    case INCREMENT:
    case DECREMENT:
    case PLUS:
    case MINUS:
    case 132:
      val = annotationValue();
                              vals.add(val);
      label_46:
      while (true) {
        if (jj_2_45(2)) {
          ;
        } else {
          break label_46;
        }
        jj_consume_token(COMMA);
        val = annotationValue();
                                                 vals.add(val);
      }
      break;
    default:
      jj_la1[147] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[148] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
      {if (true) return new ArrayInitializer(vals, _range(first, token));}
    throw new Error("Missing return statement in function");
  }

  // Lookahead productions ////////////////////////////////////////////////////////

  /** Distinguish a cast expression from a parenthesized expression. */
  final public void castLookahead() throws ParseException {
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
      primitiveType();
      break;
    case IDENTIFIER:
      type();
      jj_consume_token(RPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        jj_consume_token(TILDE);
        break;
      case BANG:
        jj_consume_token(BANG);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case THIS:
        jj_consume_token(THIS);
        break;
      case SUPER:
        jj_consume_token(SUPER);
        break;
      case NEW:
        jj_consume_token(NEW);
        break;
      case FALSE:
      case NULL:
      case TRUE:
      case INTEGER_LITERAL:
      case LONG_LITERAL:
      case FLOAT_LITERAL:
      case DOUBLE_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
        literal();
        break;
      default:
        jj_la1[149] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[150] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  /** Distinguish an unmodified constructor declaration from other declarations. */
  final public void constructorLookahead() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LESS:
      typeParameters();
      break;
    default:
      jj_la1[151] = jj_gen;
      ;
    }
    jj_consume_token(IDENTIFIER);
    jj_consume_token(LPAREN);
  }

  /** Distinguish an unmodified method declaration from other declarations. */
  final public void methodLookahead() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LESS:
      typeParameters();
      break;
    default:
      jj_la1[152] = jj_gen;
      ;
    }
    resultType();
    jj_consume_token(IDENTIFIER);
    jj_consume_token(LPAREN);
  }

  /** Distinguish an unmodified variable or field declaration from other declarations. */
  final public void variableLookahead() throws ParseException {
    type();
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      break;
    case ASSIGN:
      jj_consume_token(ASSIGN);
      break;
    case COMMA:
      jj_consume_token(COMMA);
      break;
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case RBRACE:
      jj_consume_token(RBRACE);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[153] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_3R_184() {
    if (jj_3R_195()) return true;
    return false;
  }

  private boolean jj_3R_183() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(132)) jj_scanpos = xsp;
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }

  private boolean jj_3R_164() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_127() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  private boolean jj_3_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(0)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) return true;
    }
    return false;
  }

  private boolean jj_3R_126() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(ASSERT)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_233() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_125() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  private boolean jj_3R_232() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  private boolean jj_3R_181() {
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  private boolean jj_3R_231() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) {
    jj_scanpos = xsp;
    if (jj_3R_236()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_3R_133()) return true;
    return false;
  }

  private boolean jj_3R_173() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_88() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_179() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = !opt.requireSemicolon();
    jj_lookingAhead = false;
    if (!jj_semLA || jj_scan_token(0)) return true;
    }
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_3R_113()) return true;
    return false;
  }

  private boolean jj_3R_144() {
    if (jj_scan_token(IF)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_173()) return true;
    }
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_3R_164()) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3R_93() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) return true;
    }
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_57()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3_6()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_3R_111()) return true;
    return false;
  }

  private boolean jj_3R_85() {
    Token xsp;
    xsp = jj_scanpos;
    jj_lookingAhead = true;
    jj_semLA = lookaheadFlag;
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) return true;
    }
    return false;
  }

  private boolean jj_3R_230() {
    if (jj_3R_231()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_3R_109()) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_52()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3_9()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_142() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_94() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_142()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_229() {
    if (jj_3R_230()) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_180() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_211() {
    if (jj_3R_132()) return true;
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_116()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_211()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_193() {
    if (jj_3R_132()) return true;
    return false;
  }

  private boolean jj_3R_206() {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_193()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_12()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_31() {
    if (jj_3R_85()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3_31()) return true;
    }
    return false;
  }

  private boolean jj_3_30() {
    if (jj_3R_84()) return true;
    return false;
  }

  private boolean jj_3R_205() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_3R_155()) return true;
    return false;
  }

  private boolean jj_3R_228() {
    if (jj_3R_229()) return true;
    return false;
  }

  private boolean jj_3R_204() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  private boolean jj_3R_76() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(53)) jj_scanpos = xsp;
    if (jj_3R_116()) return true;
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_3R_154()) return true;
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_180()) return true;
    }
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3R_105() {
    if (jj_3R_152()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_3R_151()) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_3R_150()) return true;
    return false;
  }

  private boolean jj_3R_203() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_3R_148()) return true;
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_3R_147()) return true;
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_3R_146()) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_3R_145()) return true;
    return false;
  }

  private boolean jj_3R_202() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_3R_144()) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_3R_143()) return true;
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_3R_116()) return true;
    return false;
  }

  private boolean jj_3R_201() {
    if (jj_scan_token(DOUBLE_LITERAL)) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_200() {
    if (jj_scan_token(FLOAT_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_191() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_11()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_153() {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3_24() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_29() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_194() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_175() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3_29()) return true;
    }
    return false;
  }

  private boolean jj_3R_199() {
    if (jj_scan_token(LONG_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_178() {
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3_23() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3R_227() {
    if (jj_3R_228()) return true;
    return false;
  }

  private boolean jj_3_25() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_198() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_187() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_57()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3_25()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_3R_183()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_157() {
    if (jj_3R_182()) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_3R_181()) return true;
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_178()) jj_scanpos = xsp;
    if (jj_3R_179()) return true;
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_52()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    }
    return false;
  }

  private boolean jj_3R_110() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_226() {
    if (jj_3R_227()) return true;
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_3R_187()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3_28()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_151() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(77)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3_42() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3_41() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_225() {
    if (jj_3R_226()) return true;
    return false;
  }

  private boolean jj_3_43() {
    Token xsp;
    if (jj_3_41()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_41()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_22()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_scan_token(IMPORT)) return true;
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(77)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  private boolean jj_3R_223() {
    if (jj_3R_225()) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_3R_90()) return true;
    return false;
  }

  private boolean jj_3R_118() {
    if (jj_3R_163()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) return true;
    }
    return false;
  }

  private boolean jj_3R_224() {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  private boolean jj_3R_109() {
    if (jj_scan_token(PACKAGE)) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_79()) return true;
    return false;
  }

  private boolean jj_3R_213() {
    if (jj_3R_223()) return true;
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_3R_94()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(0)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_92()) jj_scanpos = xsp;
    if (jj_3R_93()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_111() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_159()) jj_scanpos = xsp;
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_222() {
    if (jj_3R_224()) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_3R_137()) return true;
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_3R_94()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_75() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_115()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_221() {
    if (jj_3R_132()) return true;
    return false;
  }

  private boolean jj_3R_220() {
    if (jj_scan_token(SUPER)) return true;
    return false;
  }

  private boolean jj_3R_219() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  private boolean jj_3R_218() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  private boolean jj_3R_123() {
    if (jj_3R_94()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_3R_165()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_217() {
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_3R_88()) return true;
    return false;
  }

  private boolean jj_3R_216() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_215() {
    if (jj_3R_187()) return true;
    return false;
  }

  private boolean jj_3R_214() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_212() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_209() {
    if (jj_3R_213()) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) return true;
    }
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_3R_132()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) return true;
    }
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(STRICTFP)) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_35() {
    if (jj_3R_86()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3R_177() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3_34() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_33() {
    if (jj_3R_86()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_3R_117()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_170() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  private boolean jj_3R_190() {
    if (jj_3R_209()) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(STATIC)) return true;
    return false;
  }

  private boolean jj_3R_136() {
    if (jj_3R_170()) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_3R_114()) return true;
    return false;
  }

  private boolean jj_3R_91() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_134() {
    if (jj_3R_133()) return true;
    return false;
  }

  private boolean jj_3R_208() {
    if (jj_scan_token(SUPER)) return true;
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3_20() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_78()) return true;
    return false;
  }

  private boolean jj_3_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_3R_89()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(NATIVE)) return true;
    return false;
  }

  private boolean jj_3R_149() {
    if (jj_scan_token(FOR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_177()) return true;
    }
    return false;
  }

  private boolean jj_3_44() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  private boolean jj_3R_169() {
    if (jj_3R_190()) return true;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(VOLATILE)) return true;
    return false;
  }

  private boolean jj_3R_197() {
    if (jj_3R_212()) return true;
    return false;
  }

  private boolean jj_3R_114() {
    if (jj_scan_token(132)) return true;
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(TRANSIENT)) return true;
    return false;
  }

  private boolean jj_3R_207() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_168() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_3R_169()) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  private boolean jj_3_32() {
    if (jj_3R_77()) return true;
    return false;
  }

  private boolean jj_3R_243() {
    if (jj_3R_197()) return true;
    return false;
  }

  private boolean jj_3R_189() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_188() {
    if (jj_scan_token(HOOK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_207()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_208()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_166() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) return true;
    }
    return false;
  }

  private boolean jj_3R_112() {
    if (jj_3R_94()) return true;
    return false;
  }

  private boolean jj_3R_182() {
    if (jj_scan_token(ENUM)) return true;
    return false;
  }

  private boolean jj_3R_167() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_166()) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_scan_token(PROTECTED)) return true;
    return false;
  }

  private boolean jj_3R_176() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_196() {
    if (jj_scan_token(DECREMENT)) return true;
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_scan_token(LESS)) return true;
    if (jj_3R_166()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_167()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_168()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_scan_token(PUBLIC)) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_scan_token(SWITCH)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_176()) return true;
    }
    return false;
  }

  private boolean jj_3R_195() {
    if (jj_scan_token(INCREMENT)) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_48()) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_75()) return true;
    return false;
  }

  private boolean jj_3R_210() {
    if (jj_scan_token(BITWISE_AND)) return true;
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_scan_token(FINAL)) return true;
    return false;
  }

  private boolean jj_3R_192() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_94()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_210()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_39() {
    if (jj_3R_88()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_242() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_171() {
    if (jj_3R_191()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_192()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_3R_87()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_scan_token(ABSTRACT)) return true;
    return false;
  }

  private boolean jj_3_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_147() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_175()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    Token xsp;
    if (jj_3_10()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_10()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3R_174() {
    if (true) { jj_la = 0; jj_scanpos = jj_lastpos; return false;}
    return false;
  }

  private boolean jj_3R_241() {
    if (jj_3R_243()) return true;
    return false;
  }

  private boolean jj_3R_240() {
    if (jj_3R_242()) return true;
    return false;
  }

  private boolean jj_3R_172() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_171()) return true;
    return false;
  }

  private boolean jj_3R_239() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  private boolean jj_3R_137() {
    if (jj_scan_token(LESS)) return true;
    if (jj_3R_171()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_172()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_168()) return true;
    return false;
  }

  private boolean jj_3R_238() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  private boolean jj_3R_237() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_238()) {
    jj_scanpos = xsp;
    if (jj_3R_239()) {
    jj_scanpos = xsp;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3R_241()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_57() {
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(WHILE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_3R_174()) return true;
    }
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_3R_57()) return true;
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_117() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) return true;
    }
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  private boolean jj_3R_236() {
    if (jj_3R_237()) return true;
    return false;
  }

  private boolean jj_3R_235() {
    if (jj_3R_196()) return true;
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  private boolean jj_3R_186() {
    if (jj_3R_197()) return true;
    return false;
  }

  private boolean jj_3R_234() {
    if (jj_3R_195()) return true;
    return false;
  }

  private boolean jj_3R_185() {
    if (jj_3R_196()) return true;
    return false;
  }

  private boolean jj_3R_128() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[154];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x20400000,0x20400000,0x0,0x0,0x20400000,0x20404000,0x20404000,0x20404000,0x20404000,0x4000,0x4000,0x0,0x0,0x0,0x0,0x20400000,0x0,0x0,0x0,0x0,0x40000000,0x0,0x28654000,0x20400000,0x28654000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8254000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x28654000,0x20400000,0x0,0x0,0x4000,0x28654000,0x0,0x0,0x0,0x0,0x88250000,0x0,0x88250000,0x20400000,0x20400000,0x5028000,0x5028000,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x2080000,0x2080000,0x0,0x0,0x88250000,0x88254000,0x88250000,0x88250000,0x0,0x0,0x0,0x88250000,0x0,0x100000,0x0,0x0,0x0,0x88250000,0x0,0x0,0x0,0x0,0x88250000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x88250000,0x88250000,0x0,0x88250000,0x8250000,0x0,0x0,0x0,0x400000,0x88250000,0x0,0x0,0x88250000,0x0,0x8250000,0x0,0x0,0x0,0x88250000,0x80000000,0x8250000,0x0,0x8250000,0x8250000,0x0,0x0,0x40000000,0x0,0x0,0x40000000,0x0,0x8250000,0x0,0x0,0x88250000,0x0,0x88250000,0x88250000,0x0,0x80000000,0x8250000,0x0,0x0,0x1,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x8400,0x8480,0x80,0x80,0x8400,0x22679481,0x22671401,0x22671401,0x22679481,0x22671001,0x22671001,0x0,0x200000,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x40,0x22771e05,0x400,0x22771e05,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x22771a05,0x0,0x0,0x200000,0x0,0x10000000,0x0,0x0,0x0,0x22771e05,0x400,0x0,0x40,0x22671001,0x22771e05,0x0,0x0,0x0,0x0,0x44906a04,0x0,0x44906a04,0x400,0x400,0x8b080028,0x8b080028,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x44906a04,0x66f77a05,0x44906a04,0x44906a04,0x0,0x0,0x0,0x44906a04,0x0,0x0,0x0,0x2,0x0,0x44906a04,0x0,0x0,0x0,0x0,0x44906a04,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x44906a04,0x44906a04,0x0,0x44906a04,0x100a04,0x0,0x0,0x4802000,0x4802000,0x44906a04,0x0,0x4800000,0x44906a04,0x0,0x100a04,0x0,0x0,0x0,0x44906a04,0x40004000,0x100a04,0x0,0x100a04,0x100a04,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x100a04,0x0,0x0,0x44906a04,0x0,0x44906a04,0x44906a04,0x0,0x44806000,0x100a04,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x2,0x400002,0x400002,0x2,0x2,0x2,0x2000,0x0,0x2000,0x1000000,0x0,0x8000000,0x8000000,0x800000,0x8000000,0x0,0x0,0x8442003,0x0,0x8402003,0x100000,0x2000000,0x800000,0x100000,0x2000000,0x400000,0x8000000,0x100000,0x0,0x440000,0x800000,0x2002,0x0,0x100000,0x0,0x8000000,0x0,0x0,0x8000000,0x0,0x8402003,0x0,0x400000,0x0,0x2002,0x8442003,0x400000,0x800000,0x10000,0x40000,0x38053b19,0x800000,0x38053b19,0x0,0x0,0x440004,0x440004,0x10000,0x0,0x80000000,0x10000,0x10000,0x10000,0x40000,0x0,0x0,0x80000000,0x10000,0x8413b19,0x8413b1b,0x38013b19,0x8013b19,0x800000,0x2000,0x2000,0x38013b19,0x10000,0x0,0x10000,0x0,0x400000,0x38013b19,0x400000,0x2000000,0x2000000,0x2000000,0x8013b19,0x2000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000000,0xc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x38013b19,0x38013b19,0x30000000,0x8013b19,0x2000,0x0,0x0,0x2000,0x8002000,0x38213b19,0x9150000,0x2000,0x8013b19,0x100000,0x8002000,0x100000,0x100000,0x800000,0x38013b19,0x1b18,0x2000,0x100000,0x2001,0x0,0x800000,0x0,0x0,0x8000000,0x800000,0x0,0x0,0x40002000,0x4000000,0x800000,0x38053b19,0x10000,0x38053b19,0x38053b19,0x800000,0x30013b18,0x2000,0x8000000,0x8000000,0x2d80000,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0xc0,0x3c0,0xc0,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x0,0xffe0000,0xffe00c0,0xffe00c0,0xc0,0xffe0000,0x0,0x10,0x20,0x2000,0x4000,0x1000,0x9,0x9,0x0,0x6,0x6,0x80010000,0x80010000,0x300,0x300,0x8c00,0x8c00,0x3c0,0x3c0,0x0,0x0,0x0,0xc0,0xc0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x3c0,0x0,0x3c0,0x3c0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x10,0x10,0x0,0x0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x10,0x10,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x0,0x10,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[45];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 154; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 154; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 154; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 154; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 154; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 154; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        exists = true;
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.add(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[133];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 154; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 133; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 45; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
